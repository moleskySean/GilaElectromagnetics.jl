<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · GilaElectromagnetics.jl Documentation</title><meta name="title" content="Examples · GilaElectromagnetics.jl Documentation"/><meta property="og:title" content="Examples · GilaElectromagnetics.jl Documentation"/><meta property="twitter:title" content="Examples · GilaElectromagnetics.jl Documentation"/><meta name="description" content="Documentation for GilaElectromagnetics.jl Documentation."/><meta property="og:description" content="Documentation for GilaElectromagnetics.jl Documentation."/><meta property="twitter:description" content="Documentation for GilaElectromagnetics.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GilaElectromagnetics.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GilaElectromagnetics</a></li><li><a class="tocitem" href="../concepts/">Concepts</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Basic-Example"><span>Basic Example</span></a></li><li><a class="tocitem" href="#dipole"><span>Dipole in a cube</span></a></li><li><a class="tocitem" href="#wave-guide"><span>Dipole in a wave guide</span></a></li><li><a class="tocitem" href="#thin-film"><span>Incident wave on a thin film</span></a></li></ul></li><li><a class="tocitem" href="../library/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moleskySean/GilaElectromagnetics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moleskySean/GilaElectromagnetics.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>The following section serves as a showcase of possible applications of GilaElectromagnetics. Every one after the <a href="#basic">basic example</a> assumes that the operators presented in the <a href="../usage/">usage</a> section were defined beforehand. Only the most important parts of the source code that made the shown figures are presented here, otherwise this section would be unnecessarily long. However, complete scripts are available in the <code>examples/</code> folder of the package repository. They cover everything in this showcase, including the code to produce the figures.</p><h2 id="Basic-Example"><a class="docs-heading-anchor" href="#Basic-Example">Basic Example</a><a id="Basic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Example" title="Permalink"></a></h2><p>The following creates a self Green&#39;s function that acts on a vector of random sources. The Green&#39;s function acts in a domain that is 8x8x8 cells, each with a size that is 1/32 of a wavelength. The domain is thus 1/4 of a wavelength in each direction.</p><pre><code class="language-julia hljs">using GilaElectromagnetics

num_cells = (8, 8, 8)
cell_size = (1//32, 1//32, 1//32)
has_gpu = false # Set to true if you have a CUDA enabled GPU
const T = ComplexF32 # Set to ComplexF64 for double precision

G = GlaOpr(num_cells, cell_size; useGpu=has_gpu, setTyp=T)
source_vec = rand(eltype(G), size(G, 2))
field_vec = G * source_vec # Apply the Greens operator to the source vector</code></pre><h2 id="dipole"><a class="docs-heading-anchor" href="#dipole">Dipole in a cube</a><a id="dipole-1"></a><a class="docs-heading-anchor-permalink" href="#dipole" title="Permalink"></a></h2><p>For all cases presented below (<a href="#dipole">dipole example</a>, <a href="#wave-guide">wave guide example</a>, <a href="#thin-film">thin film example</a>), the following packages must be imported:</p><pre><code class="language-julia hljs"># Computation
using Base.Threads
using FFTW
using IterativeSolvers
using LinearAlgebra
using LinearAlgebra.BLAS
using Random
using ..GilaOperators # if the operators are in an included GilaOperators.jl file
using CUDA

# Plotting
using GLMakie
using GeometryBasics
using Colors
using Printf</code></pre><p>Also, to ensure consistency for packages that themselves use <code>Random</code>, the following line is included:</p><pre><code class="language-julia hljs">Random.seed!(0)</code></pre><p>All code sections presented below are written for maximum clarity. They could be rewritten more concisely, which could be better for certain users.</p><p>This first example is the simplest. A single electric dipole <span>$\textbf{p}_i$</span> will be placed approximately in the middle of a dielectric cube, itself embedded in empty space. The objective is to visualize the resulting electric field. Both the intensity and the real part (in every direction) are of interest.</p><h3 id="Volume-and-medium"><a class="docs-heading-anchor" href="#Volume-and-medium">Volume and medium</a><a id="Volume-and-medium-1"></a><a class="docs-heading-anchor-permalink" href="#Volume-and-medium" title="Permalink"></a></h3><p>To begin, we define most of the relevant physical quantities to describe the system:</p><pre><code class="language-julia hljs"># dimensions
num_cells_side = 32 # defines cube of 32x32x32
num_cells_side_vac = 128 # defines cube of 128x128x128
cells_per_wavelength = 32

# medium
χ_fill = ComplexF32(1.5 + 0im)

# source (dipole)
pos_x = 16
pos_y = 16
pos_z = 16
dip_x = 0
dip_y = 0
dip_z = 30

# visualisation
dst_slice = 64</code></pre><p>Special care must be taken when specifying the type of complex variables while using Gila. The user must either use <code>ComplexF32</code> for speed and memory gains, or <code>ComplexF64</code> for accuracy gains. It is not recommended to mix these two types in one single script, hence why their declaration is explicit in the code presented.</p><p>Next, the computation using Gila can be done, but only for the inside of the dielectric. We cannot just solve for both the dielectric and the empty space, because the solver doesn&#39;t converge for <code>χ = 0</code>. We can use the exact same logic as presented in the scattering section of the <a href="../usage/">usage</a> page:</p><pre><code class="language-julia hljs"># memory for volume
cells = (num_cells_side, num_cells_side, num_cells_side)
scale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)
coord = (0//1, 0//1, 0//1)

# memory for medium (small cube of dielectric)
χ = fill(χ_fill, num_cells_side, num_cells_side, num_cells_side)

# Lippmann-Schwinger operator
ls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)

# memory for dipole
p_i = zeros(eltype(ls), num_cells_side, num_cells_side, num_cells_side, 3)
p_i[pos_x, pos_y, pos_z, :] = [dip_x, dip_y, dip_z]

# solution for total polarisation current density 
p_t = solve(ls, p_i)</code></pre><h3 id="empty"><a class="docs-heading-anchor" href="#empty">Embedding in empty space</a><a id="empty-1"></a><a class="docs-heading-anchor-permalink" href="#empty" title="Permalink"></a></h3><p>We now have <code>p_t</code>, which is only present in the dielectric cube. A trick to solve for the fields is to embed this array in a bigger one filled with zeros, which represents empty space. It makes physical sense because where there is no matter there cannot be presence of a dipole. This can be implemented in the following way:</p><pre><code class="language-julia hljs"># memory for volume with empty space
cells_vac = (num_cells_side_vac, num_cells_side_vac, num_cells_side_vac)

# position of small cube within bigger one
# this is specifically to position it near the middle
pos_cube_begin = Int((num_cells_side_vac / 2) - (num_cells_side / 2))
pos_cube_end = Int((num_cells_side_vac / 2) + (num_cells_side / 2) - 1)

# insert the p_t vectors in the empty space
p_t_vac = zeros(ComplexF32, num_cells_side_vac, num_cells_side_vac, num_cells_side_vac, 3)
p_t_vac[pos_cube_begin:pos_cube_end, pos_cube_begin:pos_cube_end, pos_cube_begin:pos_cube_end, :] .= p_t</code></pre><p>With the sources embedded in empty space, nothing prevents the generation of a Green&#39;s operator. Thus, the field can be obtained like this:</p><pre><code class="language-julia hljs"># memory for Green&#39;s function
G_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)

# obtaining the electric field
e_t_vac = G_0_vac * p_t_vac</code></pre><p>This is what we aimed to obtain. All that remains is to visually represent this field.</p><div class="admonition is-info"><header class="admonition-header">Alternative trick for empty space</header><div class="admonition-body"><p>If one wants to define <span>$\chi$</span> with some empty space cells, it is possible to give a very low susceptibility value to approximate <span>$\chi = 0$</span>. Of course, this comes at a loss of accuracy, but it might be good enough depending on the use case when empty space is approximated at <span>$\sim 10^{-5}$</span>.</p><p>In the future, a preconditionner for the solver will allow materials of value <span>$\chi \leq 0$</span> to have a solution that converges, making the workarounds irrelevant.</p></div></div><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>As specified, the visualization source code for the figures is available, but is not as relevant as the solving steps in the context of the GilaElectromagnetics package. Quick tips will be provided to guide towards a clear representation of the physics, but the presentation of the results will be straightforward.</p><p>The central package used for visualisations is <a href="https://docs.makie.org/stable/">Makie.jl</a>. It allows for the most options compared to it&#39;s alternative when it comes to interactivity and customizability. As seen in the list of packages above, <code>GLMakie</code> is used as the choice of backend package to harness the power of a dedicated graphics card with <em>OpenGL</em>.</p><p>We have obtained a 3D vector field in the previous section. The first way one would think of representing it visually is with a function such as <code>arrows</code>, where every cell has its electric field vector represented. The problem with the 3D nature of the field is that such a representation gets <em>extremely</em> cluttered. It is advised to choose a 2D plane within the 3D field as a way to declutter the view.</p><p>It is not guaranteed however that the vectors within the 2D plane are coplanar with it, which leads to akwardness in the usage of the <code>arrows</code> function in 2D plane. This is why the presented figures here show <em>heat maps</em> as a way to show the data. Using Makie&#39;s <code>heatmap</code> function along with <code>Colorbar</code>, it is possible to reprint the intensity and the real parts of the electric field in a plane of the volume in a clear and intuitive way.</p><p>In the initialization of the volume and the medium, the parameter <code>dst_slice</code> was set. If the plane represented was in directions <code>xz</code>, this would mean that the slice is taken at the set number of cells from the origin. This can be seen in the following image where the heat map of the intensity <span>$E^2$</span> is accompanied by a visual aid and information on the system :</p><p><img src="../assets/cube_1.png" alt="dipole in cube - intensity - slice on dipole"/></p><p>This image represents the exact physical case with the numeric values presented above in the <code>xz</code> plane. For clarity and since the intensity is strictly positive, the color scales logarithmically. In addition, the real part of the electric field vector in every Cartesian direction, respectively <span>$E_x$</span>, <span>$E_y$</span>, <span>$E_z$</span>, for this same system is shown here :</p><p><img src="../assets/cube_2.png" alt="dipole in cube - real part - slice on dipole"/></p><p>As it can be seen, the values of the electric field at the dipole saturate the colour map. To see more clearly the behaviour of the field as it gets further away from the dipole, the same figures were made but with the plane of visualization further away from the dipole, at <code>dst_slice = 70</code> :</p><p><img src="../assets/cube_3.png" alt="dipole in cube - intensity - slice offset"/></p><p>For the real part at this distance of visualization:</p><p><img src="../assets/cube_4.png" alt="dipole in cube - real part - slice offset"/></p><p>The decay of the field with the behaviour on the edge of the cube is as expected.</p><h2 id="wave-guide"><a class="docs-heading-anchor" href="#wave-guide">Dipole in a wave guide</a><a id="wave-guide-1"></a><a class="docs-heading-anchor-permalink" href="#wave-guide" title="Permalink"></a></h2><p>Similarly, the second example shows an electric dipole located in a wave guide. The same process of embedding the dielectric in a bigger space will be used.</p><h3 id="Volume-and-medium-2"><a class="docs-heading-anchor" href="#Volume-and-medium-2">Volume and medium</a><a class="docs-heading-anchor-permalink" href="#Volume-and-medium-2" title="Permalink"></a></h3><p>Very similarly to the cube, we define relevant physical quantities, with more granularity on the dimensions of the volumes. The embedding position of the dielectric in vacuum is predetermined here, where the <code>position_guide</code> variables give the number of cells between the beginning of the guide and the relevant plane crossing the origin :</p><pre><code class="language-julia hljs"># dimensions of guide
num_cellsx = 256
num_cellsy = 34
num_cellsz = 34

# dimensions of space
num_cellsx_vac = num_cellsx
num_cellsy_vac = 256
num_cellsz_vac = 128
cells_per_wavelength = 32

# location of guide (only intended for guide along x)
position_guide_y = 110
position_guide_z = 55

# medium
χ_fill = ComplexF32(1.5 + 0im)

# source
pos_x = 50 
pos_y = 16
pos_z = 16
dip_x = 0
dip_y = 0
dip_z = 10

# visualisation
dst_slice = 135
slice_id = &quot;xz&quot;</code></pre><p>As specified in a comment, this prepares a wave guide along the x-axis only, but the program can be modified for any direction. </p><h3 id="Decay-and-loss-at-boundaries"><a class="docs-heading-anchor" href="#Decay-and-loss-at-boundaries">Decay and loss at boundaries</a><a id="Decay-and-loss-at-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Decay-and-loss-at-boundaries" title="Permalink"></a></h3><p>An important detail must be addressed before solving for the electric field. A key difference with the cube example is that the dielectric goes all the way to the edges of the defined volume. A conventional wave guide would be normally treated under an approximation of infinite length, because its length is much bigger than the size of its cross-section. Here, the edges prevent this approximation, because the computation treats them as a medium-vacuum interface.</p><p>To massively reduce the impact of this interface, we can introduce a gradual decay of <span>$\Re(\chi)$</span>, which makes the transition from dielectric to vacuum much smoother, reducing reflection effects in the guide. In addition, we can gradually introduce loss in the medium, by increasing <span>$\Im(\chi)$</span> when approaching the boundary.</p><p>The following function scales the decay with a <span>$\tanh$</span> function, going from <span>$\Re(\chi)\times\tanh(3)$</span> to <span>$\Re(\chi)\times\tanh(-3)$</span> as the boundary approaches. This decay happens on a length determined by the parameter <code>decay_length</code> given in number of wavelengths. Similarly, loss is introduced on this same length proportionally to <span>$x^2$</span>, going from <span>$\Im(\chi) = 0$</span> to <span>$\Im(\chi) = 0.1$</span> : </p><pre><code class="language-julia hljs">function medium_decay_tanh!(cells, χ, χ_fill, d)
  for i in 1:d
    χ[d-i+1, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
    χ[cells[1] - d + i, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
  end
end</code></pre><p>Applying this function to the already defined medium will greatly help the simulations to have intended results everywhere except where the decay and loss happens. In these locations, the fields should simply vanish.</p><div class="admonition is-info"><header class="admonition-header">function() VS function!()</header><div class="admonition-body"><p>A typical <code>function</code> returns something, while a <code>function!</code> modifies one or more of it&#39;s input variables. The <code>!</code> is Julia convention to indicate this fact.</p><p>As an example, <code>medium_decay_tanh!</code> modifies the <code>χ</code> variable directly. Some functions in Gila use this convention, notably <code>egoOpr!</code> and other internal functions.</p></div></div><h3 id="Solutions"><a class="docs-heading-anchor" href="#Solutions">Solutions</a><a id="Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Solutions" title="Permalink"></a></h3><p>Solving for the field is just like the cube case, with the addition of the decay function. A script to obtain it would look like this :</p><pre><code class="language-julia hljs"># solving in the dielectric
cells = (num_cellsx, num_cellsy, num_cellsz)
scale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)
coord = (0//1, 0//1, 0//1);

χ = fill(χ_fill, num_cellsx, num_cellsy, num_cellsz)
decay_length = 1
medium_decay_tanh!(cells, χ, χ_fill, decay_length * cells_per_wavelength);

ls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)

p_i = zeros(eltype(ls), num_cellsx, num_cellsy, num_cellsz, 3)
p_i[pos_x, pos_y, pos_z, :] = [dip_x, dip_y, dip_z]

p_t = solve(ls, p_i)

# embedding in empty space
cells_vac = (num_cellsx, num_cellsy_vac, num_cellsz_vac)

end_guide_y = position_guide_y + num_cellsy - 1
end_guide_z = position_guide_z + num_cellsz - 1

p_t_vac = zeros(ComplexF32, num_cellsx, num_cellsy_vac, num_cellsz_vac, 3)

p_t_vac[:, position_guide_y:end_guide_y, position_guide_z:end_guide_z, :] .= p_t

G_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)

e_t_vac = G_0_vac * p_t_vac</code></pre><p>We can now visualize the field in the guide with heatmaps, with the viewed plane slightly away from where the dipole is so that the gradient of colour is less saturated:</p><p><img src="../assets/guide_1.png" alt="dipole in guide - intensity - xz"/></p><p>For the real parts:</p><p><img src="../assets/guide_2.png" alt="dipole in guide - real - xz"/></p><p>We can also analyze the field in the <code>yz</code> plane to see how it leaks out of the guide:</p><p><img src="../assets/guide_3.png" alt="dipole in guide - intensity - yz"/></p><p>And finally, for the real parts:</p><p><img src="../assets/guide_4.png" alt="dipole in guide - real - yz"/></p><h2 id="thin-film"><a class="docs-heading-anchor" href="#thin-film">Incident wave on a thin film</a><a id="thin-film-1"></a><a class="docs-heading-anchor-permalink" href="#thin-film" title="Permalink"></a></h2><p>As the final example, we will analyze the behaviour of a plane wave hitting a thin film of dielectric. The general process is still the same, but the treatment of the wave itself is worth discussing.</p><h3 id="Volume-and-medium-3"><a class="docs-heading-anchor" href="#Volume-and-medium-3">Volume and medium</a><a class="docs-heading-anchor-permalink" href="#Volume-and-medium-3" title="Permalink"></a></h3><p>We define the information on the volume and the medium with the following variables:</p><pre><code class="language-julia hljs"># dimensions
num_cellsx = 256
num_cellsy = 256
num_cellsz = 24
num_cellsz_vac = 128
cells_per_wavelength = 32

# medium
position_film = 52
χ_fill = ComplexF32(1.5 + 0im)
decay_length = 1

# visualisation
dst_slice = 128</code></pre><p>Because the film goes all the way to the edges of the volume, we need to apply decay and loss again, but this time for two directions. The following function accomplishes this as it was described for the guide:</p><pre><code class="language-julia hljs">function medium_decay_tanh!(cells, χ, χ_fill, d)
  for i in 1:d
    χ[d-i+1, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
    χ[cells[1] - d + i, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
  end
  for i in 1:d
    for x in 1:cells[1]
      if real(χ[x, d-i+1, 1, 1]) &gt; real((χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ))
        χ[x, d-i+1, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
        χ[x, cells[2] - d + i, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im
      end
    end
  end
end</code></pre><h3 id="Electric-field"><a class="docs-heading-anchor" href="#Electric-field">Electric field</a><a id="Electric-field-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-field" title="Permalink"></a></h3><p>We need to create a function that generates a plane wave, and then use it to define the initial polarization current density required to use the solver. An electric wave can be described as the following :</p><p class="math-container">\[\textbf{E} = \textbf{E}_0 e^{i(\textbf{k}\cdot\textbf{r}-ωt)}\]</p><p>where the amplitude of <span>$\textbf{E}_0$</span> describes the amplitude of the wave, its direction dictates the direction of the electric field (the polarization of the wave), <span>$\textbf{k}$</span> is the wave vector which dictates both wavelength and the direction of the wave front, <span>$\textbf{r}$</span> represents a point in space, and <span>$ωt$</span> represents a phase factor that will be set to 0 arbitrarily going forward.</p><p>We will do heatmaps in <code>xz</code>, and purposefully use a wavevector coplanar to this plane. This is only for the sake of representation, as any wave vector would work. We will also arbitrarily choose an <em>s-polarized wave</em>, where the direction of the electric field is perpendicular to the plane (field along <code>y</code>). This is all set up in the following function which gives the electric field at a point:</p><pre><code class="language-julia hljs">function electric_field(x, y, z, dir_i, dir_j, dir_k, amp, ω=0, t=0)
  k = normalize([dir_i, dir_j, dir_k])
  
  if abs(k[3]) != 1
    v = [0, 0, 1]  # use z-axis if k is not aligned with z
  else
    v = [0, 1, 0]  # use y-axis if k is aligned with z (would not be s pol. anymore)
  end

  # Field perpendicular to the plane containing k and the z axix (s pol.)
  E0 = amp * normalize(cross(k, v))

  return E0 * exp(1im * (dot(2π*k, [x, y, z]) - ω * t))
end</code></pre><p>where the <code>amp</code> variable was introduced to control the amplitude of the electric field. This function is also intended to have the same wavelength as what&#39;s defined by <code>cells_per_wavelength</code>. We can now set up different memory elements as we did previously:</p><pre><code class="language-julia hljs">cells = (num_cellsx, num_cellsy, num_cellsz)
scale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)
coord = (0//1, 0//1, 0//1);

χ = fill(χ_fill, num_cellsx, num_cellsy, num_cellsz)
medium_decay_tanh!(cells, χ, χ_fill, decay_length * cells_per_wavelength);

ls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)</code></pre><p>Recall the following equation for linear, non-dispersive and isotropic dielectric :</p><p class="math-container">\[\textbf{p}_i = \chi \textbf{e}_i\]</p><p>With <code>for</code> loops and this equation applied cell per cell, we can easily obtain the initial polarization current density from the electric field:</p><pre><code class="language-julia hljs"># wave vector (is normalized later)
k_i = 1.0
k_j = 0.0
k_k = -2.0 # negative value looks better, not mandatory
amp = 3.0

p_i = zeros(eltype(ls), num_cellsx, num_cellsy, num_cellsz, 3)

# p_i = χ*e_i at every cell of the dielectric
@time for x in 1:num_cellsx
    for y in 1:num_cellsy
        for z in 1:num_cellsz
            p_i[x, y, z, :] = real(electric_field((x-1) + coord[1], (y-1) + coord[2], (z-1) + coord[3], k_i, k_j, k_k, amp)) * χ[x, y, z, 1]
        end
    end
end</code></pre><p>This allows to solve for the total field with the solver and Green&#39;s operator:</p><pre><code class="language-julia hljs"># solving
p_t = solve(ls, p_i)

# embedding
cells_vac = (num_cellsx, num_cellsy, num_cellsz_vac)
end_film = position_film + num_cellsz - 1
p_t_vac = zeros(ComplexF32, num_cellsx, num_cellsy, num_cellsz_vac, 3)
p_t_vac[:, :, position_film:end_film, :] .= p_t

# obtaining fields
G_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)
e_t_vac = G_0_vac * p_t_vac</code></pre><p>We are now ready to plot heatmaps of this wave. Starting with different information and the intensity:</p><p><img src="../assets/film_1.png" alt="film - 1, 0 , -2 - decay - intensity"/></p><p>And then, the real parts of the field:</p><p><img src="../assets/film_2.png" alt="film - 1, 0 , -2 - decay - real"/></p><p>As intended, most of the field is contained in the <code>y</code> direction because of the initial s-polarisation. However, a lot more confinement of the field in the field is observed, and the values aren&#39;t very high. This is a consequence of the decay and the loss introduced. If we reproduce the same system but without introducing them, we can observe the following. For the intensity:</p><p><img src="../assets/film_3.png" alt="film - 1, 0 , -2 - no decay - intensity"/></p><p>For the real parts:</p><p><img src="../assets/film_4.png" alt="film - 1, 0 , -2 - no decay - real"/></p><p>This is less representative of how thin films would behave in real life, but it shows nicely how the loss &quot;hides&quot; parts of the field. A way to have realistic behaviour without suppressing the field would be to simulate a <em>much</em> bigger film and to exclude the edges from the visualization, but this is quite computationally expensive.</p><h3 id="Different-angle"><a class="docs-heading-anchor" href="#Different-angle">Different angle</a><a id="Different-angle-1"></a><a class="docs-heading-anchor-permalink" href="#Different-angle" title="Permalink"></a></h3><p>We can try to simulate a wave that glances the film at a very low angle. Phenomena of total internal reflection should be recognizable. Changing the values of the wave vector, we obtain:</p><p><img src="../assets/film_9.png" alt="tir - intensity"/></p><p>Finally, the real values of the electric field are:</p><p><img src="../assets/film_10.png" alt="tir - real"/></p><p>We can indeed see a reflected wave. Its odd look on both sides is due to the small size of the simulated system and to the definition of the wave. The way it&#39;s formulated, the initial field exists on both sides of the film at the beginning, which makes it behave not exactly like a wave front at the contact of a dielectric film would. Still, expected behaviour is there, and it is a good showcase of the abilities of Gila on solving different systems.</p><h3 id="GPU-example"><a class="docs-heading-anchor" href="#GPU-example">GPU example</a><a id="GPU-example-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-example" title="Permalink"></a></h3><p>Finally, even though the solver is not yet implemented with it, here is a short showcase on how such a simulation would be treated with computation on a CUDA enabled GPU. Most of the program stays the same, but the operators need to have their <code>use_gpu</code> parameter set to true:</p><pre><code class="language-julia hljs">ls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32, use_gpu=true)

G_0_void = load_greens_operator(tuple(cells_void...), scale; set_type=ComplexF32, use_gpu=true)</code></pre><p>In addition, the initial polarization current density needs to be converted to a <code>CuArray</code> in order to be treated correctly by the solver:</p><pre><code class="language-julia hljs">p_t = Array(solve(ls, CuArray(p_i)))</code></pre><p>This would result in the total electric field variable <code>e_t_vac</code> to be of type <code>CuArray</code> also. In order to do further data analysis with it, it could be necessary to convert it back to a regular array by simply using <code>Array(e_t_vac)</code>. Right now, using CUDA to load Green&#39;s operators is working and a good way to save compute time.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../library/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 6 September 2024 16:58">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
