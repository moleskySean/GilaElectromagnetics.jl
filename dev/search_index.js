var documenterSearchIndex = {"docs":
[{"location":"concepts/#Concepts","page":"Concepts","title":"Concepts","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"GilaElectromagnetics implements the three dimensional electromagnetic Green function using a volume integral formulation to solve Maxwell's equations numerically efficiently and accurately. The concepts required for its usage are presented below.","category":"page"},{"location":"concepts/#Foundations","page":"Concepts","title":"Foundations","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"As goes with most of classical electromagnetics, the starting point is Maxwell's equations, here presented in their differential form:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"fracpartial Bpartial t + nabla times E = 0","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"fracpartial Dpartial t - nabla times H = -J_f","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"nabla cdot D = rho_f","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"nabla cdot B = 0","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"The electric and magnetic fields are denoted by E and B respectively. Associated to them are the electric displacement field D and auxiliary magnetic field B, connected by their respective constitutive relations:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"D = epsilon E","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"B = mu H = mu_0left(H + Mright)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Also present are the free charge density rho_f, the free current density J_f, the electric permittivity epsilon, the magnetic permeability mu, and the magnetization field M.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"note: Change to frequency domain\nGilaElectromagnetics works in the frequency domain. As expected, an (inverse) Fourier transform is used to rewrite equations in this domain:f(omega) = frac12piint_-infty^infty f(t)e^iomega tdt","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Of interest for Gila are the first two Maxwell equations presented above, rewritten in Fourier space and with the constitutive relations:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"J_f = iomegaepsilon E + nabla times H","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"-M = -frac1iomegamu_0nabla times E + H","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This can be compactly written in matrix form:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"beginpmatrix\nJ_f \n-M\nendpmatrix\n=\nbeginpmatrix\niomegaepsilontextbfI_3times 3  nabla times \n-frac1iomegamu_0 nabla times  textbfI_3 times 3\nendpmatrix\nbeginpmatrix\nE \nH\nendpmatrix","category":"page"},{"location":"concepts/#maxwell","page":"Concepts","title":"Notation and change of coordinates","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"The equation above must be tweaked to have a Hermitian matrix in Fourier space so that it has physical meaning.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"note: Hermitian matrix\nA square matrix A is said to be Hermitian if it is equal to its own adjoint (conjugate transpose):A = A^dagger = left(A^topright)^* = left(A^*right)^topThe eigenvalues of a Hermitian matrix are always real and may represent physical observables.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"The following change of coordinates is appropriate for this purpose :","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"textbfj = J","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"textbfm = imu_0omega M","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Z = sqrtfracmu_0epsilon","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"k_0 = omegasqrtmu_0epsilon","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"It leads to the following equation :","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"fracik_0\nbeginpmatrix\ntextbfj \n-textbfm\nendpmatrix\n=-\nbeginpmatrix\nZ^-1  -fracik_0 nabla times \nfracik_0 nabla times  Z\nendpmatrix\nbeginpmatrix\nE \nH\nendpmatrix","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Finally, the notation is simplified by denoting the vector of textbfj and textbfm by textbfp, the vector of fields E and H by textbff and the matrix, also referred to as the vacuum Maxwell operator, by textbfM_0:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"fracik_0textbfp = textbfM_0textbff","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This elegantly presents the Maxwell equations in a way that can be approached by Gila, knowing that the other two Maxwell equations that were not used in the development are satisfied. See scattering.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"The Green's function textbfG_0 of the vacuum Maxwell operator is defined as the inverse of textbfM_0:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"textbfG_0textbfM_0 = textbfI_6times 6","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"danger: What GilaElectromagnetics does\nThe purpose of GilaElectromagnetics is to compute the action of this Green's function on a vector in vacuum.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Solving for the Green's function in matter can be done indirectly with Gila. See the next section, usage, for more information.","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following presents typical uses of GilaElectromagnetics.","category":"page"},{"location":"usage/#Vacuum-Green's-function","page":"Usage","title":"Vacuum Green's function","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Gila solves Maxwell's equations in a vacuum by employing finite element methods on a given volume. What Gila computes is the action of the vacuum Green's function textbfG_0 on a vector. The operator textbfG_0 is represented in memory by the structure GlaOprMem. A simpler object to use which acts exactly as you would want an operator to behave is the GlaOpr structure. To initialize either a GlaOprMem object or a GlaOpr object, information about the space where the equations are solved must be defined.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In Gila, volumes must be rectangular prisms, which are then subdivided into smaller volumes called cells. The size of these cells in a specific direction is given in fractions of a wavelength, because Gila solves a system at one given wavelength.","category":"page"},{"location":"usage/#Self-and-external-operators","page":"Usage","title":"Self and external operators","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The vacuum Green's function for a given volume is obtained using a GlaOpr constructor. There are two cases to consider. The first one is the simplest, where the source volume is the same as the target volume. The resulting operator is called the self Green's operator. The following example shows how to build one:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Volume definition\ncells = (8, 8, 8) # Defines a volume with 8 cells in each direction\nscale = (1//32, 1//32, 1//32) # Each cell is 1/32 of a wavelength in each direction\norigin = (0//1, 0//1, 0//1) # OPTIONAL: The volume is located at the origin\n\n# Self Greens operator\nG_0 = GlaOpr(cells, scale, origin)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Origin\nThe origin in this context refers to the cell (1, 1, 1), located in the corner of the volume. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Two more parameters can be passed: useGpu if an Nvidia GPU is available, and setTyp to either use 32 or 64 bit complex numbers (single or double precision). The syntax to use these parameters is shown here:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"G_0 = GlaOpr(cells, scale, origin; useGpu=true, setTyp=ComplexF64)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The second case to consider is where there are two separate volumes, or when the defined volume (source) is different from the one where a solution is desired (target). This can be useful if a medium and current sources are defined in a region, but the space to be simulated is either partially or fully contained by the source volume, or if both are completely separated. The Green's function is then called the external Green's operator, and it can be constructed just like the self operator, only with two volumes required :","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Source volume definition\nsrc_cells = (src_nx, src_ny, src_nz) # tuple of Integers\nsrc_scale = (src_sclx, src_scly, src_sclz) # tuple of Rationals\nsrc_origin = (src_orgx, src_orgy, src_orgz) # tuple of Rationals, REQUIRED\n\n# Target volume definition\ntrg_cells = (trg_nx, trg_ny, trg_nz) # tuple of Integers\ntrg_scale = (trg_sclx, trg_scly, trg_sclz) # tuple of Rationals\ntrg_origin = (trg_orgx, trg_orgy, trg_orgz) # tuple of Rationals, REQUIRED\n\n# External Green's operator\nG_0 = GlaOpr(src_cells, src_scale, src_origin, trg_cells, trg_scale, trg_origin)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The same optionnal parameters for CUDA and the complex type could be given.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Origin\nThe origin in this context refers to the cell (1, 1, 1), located in the corner of the volume. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This operator uses the GlaOpr type, which in itself is an abstraction wrapper for the GlaOprMem. It is not a matrix, but it can be used as a linear operator, i.e., you can multiply a vector by it.","category":"page"},{"location":"usage/#scattering","page":"Usage","title":"Scattering problem","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Gila is designed primarily to tackle the scattering problem, which asks to find the total field textbff_t produced, given an incident field textbff_i and a dielectric profile. This allows us to solve Maxwell's equations in matter.","category":"page"},{"location":"usage/#Theoretical-overview","page":"Usage","title":"Theoretical overview","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can always decompose the total field into an incident and a scattered part:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbff_t = textbff_i + textbff_s","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Furthermore, we define the matrix textbfX to represent permittivity and permeability as such, while still using natural units :","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfX =\nbeginpmatrix\ntextbfX_je  textbf0 \ntextbf0  textbfX_mh\nendpmatrix","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here, textbfX_je and textbfX_mh are diagonal matrices described by the electric and magnetic susceptibility chi_e and chi_m respectively:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfX_je = fracik_0chi_e textbfI_3 times 3","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfX_mh = -fracik_0chi_m textbfI_3 times 3","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfP = epsilon_0 chi_e textbfE","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfM = chi_m textbfH","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"with textbfP, the polarization density, and textbfM, the magnetization field. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the same way that the fields can be decomposed into incident, scattered and total parts, so can the polarization density vector: textbfp_t = textbfp_i + textbfp_s. After such a decomposition, the constitutive relations become:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"fracik_0textbfp_s = textbfXtextbff_t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Recall the relevant Maxwell's equations in vacuum. By their linearity, their scattered part can be written simply as:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfM_0 textbff_s = fracik_0textbfp_s","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Combining with the previous equation:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfM_0 textbff_s = textbfXtextbff_t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With the vacuum Green's function being the inverse of textbfM_0:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbff_s = textbfG_0 textbfXtextbff_t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With the decomposition of the scattered field into its total and initial parts, along with substitutions with previous equations, the following relation can be found:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbff_t - fracik_0textbfG_0 textbfp_s =fracik_0textbfG_0 textbfp_i","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Finally, multiplying both sides by textbfX, using further substitutions and decomposing the density vector the same way the fields vector was, a crucial equation is reached:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"(textbfI_6 times 6 - textbfXtextbfG_0)textbfp_t = textbfp_i","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This is known as the Lippmann-Schwinger equation. In order to obtain the total polarization current density from the material's properties and from an initial polarization current density, the following needs to be solved:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfp_t = (textbfI_6 times 6 - textbfXtextbfG_0)^-1textbfp_i","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where textbfW = (textbfI_6 times 6 - textbfXtextbfG_0)^-1 is denoted as the scattering operator. With a way to define this operator, Gila effectively allows the Maxwell's equations to be solved in matter.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"danger: Accessing specific matrices\nIt is important to note that the mathematical solutions above would apply to a single cell of a system. For a whole system, they are still correct, but the matrices and vectors are expanded, and each cell adds six elements (on the diagonal for the matrix textbfX). This is explained further in the implementation examples. It is important to to keep in mind is that these matrices become enormous very quickly as the dimensions of a volume increases. Gila's trick is to actually not compute the Green's function, but to only compute it's application on a vector textbfv. The same would go for textbfW, since it's composed of the Green's operator. Thus, Gila outputs textbfG_0 textbfv, textbfWtextbfp_i (provided Lippmann-Schwinger is implemented) or anything similar.","category":"page"},{"location":"usage/#Implementation","page":"Usage","title":"Implementation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This section will showcase an implementation of the scattering operator, to solve the Lippmann-Schwinger equation in this context. These can be implemented as a module in a file of a project. To begin, the following packages must be imported in order for the following code to function:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# At the beginning of an exported module\nusing LinearAlgebra\nusing JLD2\nusing CUDA\nusing GilaElectromagnetics","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In a nutshell, the part that takes the longest to compute for Gila are fast Fourier transforms (FFTs). However, the implementation of JLD2 gives the possibility of storing (serializing) these FFTs, drastically speeding things up for subsequent uses of Gila for systems of identical dimensions. The following function simply verifies the existence of a folder named preload where the Fourier transforms will be stored:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function get_preload_dir()\n    found_dir = false\n    dir = \"preload/\"\n    for i in 1:10\n        if !isdir(dir)\n            dir = \"../\"^i * \"preload/\"\n        else\n            found_dir = true\n            break\n        end\n    end\n    if !found_dir\n        error(\"Could not find preload directory. Please create a directory named 'preload' in the current directory or parent directories.\")\n    end\n    return dir\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following function implements the GlaOpr with the possibility of obtaining it faster if it was serialized before:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function load_greens_operator(cells::NTuple{3, Int}, scale::NTuple{3, Rational{Int}};\n                              set_type=ComplexF64, use_gpu::Bool=false)\n\n    # Define the name of the FFT file\n\tpreload_dir = get_preload_dir()\n\ttype_str = set_type == ComplexF64 ? \"c64\" : (set_type == ComplexF32 ? \"c32\" : \"c16\")\n\tfname = \"$(type_str)_$(cells[1])x$(cells[2])x$(cells[3])_$(scale[1].num)ss$(scale[1].den)x$(scale[2].num)ss$(scale[2].den)x$(scale[3].num)ss$(scale[3].den).jld2\"\n\tfpath = joinpath(preload_dir, fname)\n\n    # If file exists, unserialise and return GlaOpr\n\tif isfile(fpath)\n\t\tfile = jldopen(fpath)\n\t\tfourier = file[\"fourier\"]\n\t\tif use_gpu\n\t\t\tfourier = CuArray.(fourier)\n\t\tend\n\t\toptions = GlaKerOpt(use_gpu)\n\t\tvolume = GlaVol(cells, scale, (0//1, 0//1, 0//1))\n\t\tmem = GlaOprMem(options, volume; egoFur=fourier, setTyp=set_type)\n\t\treturn GlaOpr(mem)\n\tend\n\n    # If file doesn't exist, generate GlaOpr, save it and return it\n\toperator = GlaOpr(cells, scale; setTyp=set_type, useGpu=use_gpu)\n\tfourier = operator.mem.egoFur\n\tif use_gpu\n\t\tfourier = Array.(fourier)\n\tend\n\tjldsave(fpath; fourier=fourier)\n\treturn operator\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With this function prepared, the memory structure of the Lippmann-Schwinger and its constructors can be defined. The following simply creates the struct for it with some error checking and preparation for the use of CUDA if required:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct LippmannSchwinger\n\tgreens_op::GlaOpr\n\tmedium::AbstractArray{<:Complex, 4}\n\n    # Simple constructor\n\tfunction LippmannSchwinger(greens_op::GlaOpr, medium::AbstractArray{<:Complex})\n\n        # Verify if the dimensions and type of GlaOpr and the medium match.\n\t\tif glaSze(greens_op, 1)[1:3] != size(medium)\n\t\t\tprintln(glaSze(greens_op, 1)[1:3])\n\t\t\tprintln(\"!=\")\n\t\t\tprintln(size(medium))\n\t\t\tthrow(DimensionMismatch(\"Green's operator and medium must have the same size.\"))\n\t\tend\n\t\tif eltype(greens_op) != eltype(medium)\n\t\t\tthrow(ArgumentError(\"Medium must have the same element type as the Green's operator.\"))\n\t\tend\n\n        # Reshape to match the mathematical definitions of the medium\n\t\tmedium = reshape(medium, glaSze(greens_op, 1)[1:3]..., 1)\n\n        # Make the medium array compatible with CUDA if it's set up\n\t\tif greens_op.mem.cmpInf.devMod\n\t\t\tmedium = CuArray(medium)\n\t\tend\n\n\t\tnew(greens_op, medium)\n\tend\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The definition of the medium as an rank 4 tensor is more intuitive for the user. The first three dimensions simply describe the indices of a cell, and the element in the fourth dimension is the complex chi_e value at the chosen cell. This tensor is then reshaped to correspond to how textbfX was defined.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"danger: Materials treated by Gila\nGilaElectromagnetics can only treat non-magnetic materials, as they are the most common in the field of nano-optics. This is why the medium only defines the electric susceptibility. For now, only values of susceptibility with Re(chi_e)  0  converge for the iterative methods used in the following sections. However, there is current development on a preconditioner which will allow negative real parts of the electric susceptibility to be used without convergence problems. This will make simulations of metals possible, and simplify the treatement of empty space.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It can also be useful to have a constructor of LippmannSchwinger that directly takes the definition of the cells, the scale, the medium and other parameters:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function LippmannSchwinger(cells::NTuple{3, Int}, scale::NTuple{3, Rational{Int}},\n                           medium::AbstractArray{<:Complex};\n                           set_type=ComplexF64, use_gpu::Bool=false)\n\n\tgreens_op = load_greens_operator(cells, scale; set_type=set_type, use_gpu=use_gpu)\n\treturn LippmannSchwinger(greens_op, medium)\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With this operator not being a matrix but its own memory type, some mathematical and typical Julia functions ought to be defined:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Informations on Lippmann-Schwinger\nBase.size(op::LippmannSchwinger) = size(op.greens_op)\nBase.size(op::LippmannSchwinger, dim::Int) = size(op.greens_op, dim)\nglaSze(op::LippmannSchwinger) = glaSze(op.greens_op)\nglaSze(op::LippmannSchwinger, dim::Int) = glaSze(op.greens_op, dim)\nBase.eltype(op::LippmannSchwinger) = eltype(op.greens_op)\n\n# Redefinition of the multiplication\nfunction Base.:*(op::LippmannSchwinger, x::AbstractArray)\n\tif op.greens_op.mem.cmpInf.devMod\n\t\tx = CuArray(x)\n\tend\n\tgx = reshape(op.greens_op * x, glaSze(op, 1))\n\treturn x - reshape(op.medium .* gx, size(x))\nend\nLinearAlgebra.mul!(y::AbstractArray, op::LippmannSchwinger, x::AbstractArray) = y .= op * x","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Similar techniques are implemented with Gila so that multiplying a Green's operator or attempting to get information on it is more seamless. The final step consists in using a solver to solve textbfp_t = (textbfI_6 times 6 - textbfXtextbfG_0)^-1textbfp_i. A simple implementation of one would go like this:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using IterativeSolvers\n\nfunction solve(ls::LippmannSchwinger, i::AbstractArray{<:Complex, 4};\n               solver=bicgstabl)\n\n    # Inversion of Lippmann-Schwinger\n    out = solver(ls, reshape(deepcopy(i), prod(size(i))))\n    return reshape(out, size(i))\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Two main solvers from IterativeSolvers.jl were tested and verified to work : BiCGStab and GMRES.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"danger: Usage of GPU with solvers\nCurrently, activating the use of CUDA and using a solver from IterativeSolvers results in an error. This is due to these solvers not working with the CuArray type of CUDA. Implementing a fix to this problem is feasible for a user, as very few changes to these packages are required. A working BiCGStab version for this use case is currently in development.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"As presented here, the solving function returns a rank 4 tensor, or an array of size 4, where the first three indices choose a cell, and the fourth contains the textbfp_t vector at that cell. Maxwell's equations in the medium are thus solved with this function.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Redefinition of the multiplication\nThe redefinition of the multiplication might seem odd, but it is essential to achieve the form textbfI_6 times 6 - textbfXtextbfG_0 in the iterative solvers. It is what allows BiCGStab or other algorithms to output textbfWtextbfp_i, the different multiplications come in handy in their underlying workings. ","category":"page"},{"location":"usage/#Fields","page":"Usage","title":"Fields","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The demonstrated solver for the scattering problem gives the total polarization current density. If an electric field is desired, the following equation can be used:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"textbfe_t = textbfG_0 textbfp_t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The only thing required is to define Green's operator for the volume. With the definition of the self Green's operator showed above and the solver, finding the total electric field for the scattering problem can be done as such:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Define the volume\ncells = (n_x, n_y, n_z)\nscale = (scl_x, scl_y, scl_z)\n\n# Define the medium, this is just a simple example\nmedium = fill(1.0 + 0.0im, n_x, n_y, n_z)\n\n# Define the operator\nG_0 = GlaOpr(cells, scale)\nLS = LippmanSchwinger(cells, scale, medium)\n\n# Define p_i. For this example, only one  at (i, j, k)\np_i = zeros(eltype(LS), n_x, n_y, n_z, 3)\np_i[i, j, k, :] = [1, 0, 0]\n\n# Solve for p_t\np_t = solve(LS, p_i)\n\n# Obtain the electric field\ne_t = G_0 * p_t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"As mentioned previously, multiplication of a Green's operator with a vector is already well-defined by Gila.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Meaning of the polarization current density\nIn the context of defining an array for textbfp_i, a single vector of polarization current density can be seen as an electric dipole at the point where the vector is located.For a linear, non-dispersive and isotropic dielectric, the following relationship can relate this polarization density to the electric field:textbfp_i = chi textbfe_iThis would apply for each cell of the defined volume.","category":"page"},{"location":"usage/#Technical-details","page":"Usage","title":"Technical details","text":"","category":"section"},{"location":"usage/#API","page":"Usage","title":"API","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The presentation above didn't present every single way to define the operators. For example, the simplest constructor of GlaOpr only takes in a GlaOprMem memory structure. It would be possible to directly define it using it's structure definition","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Multiple other functions and memory structures are made available in the API. Some allow to obtain information on the operators, such as their size or their nature (self or external operator). See the API reference for more details.","category":"page"},{"location":"usage/#Boundaries-of-a-volume","page":"Usage","title":"Boundaries of a volume","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The behaviour of space outside the defined volume is designed to be like empty space. This is referred to as open boundary conditions.","category":"page"},{"location":"usage/#Memory","page":"Usage","title":"Memory","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The operators and the matrices for bigger volumes can take a lot of memory. The following is a good rule of thumb to make sure the host doesn't run out of memory.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The size of a ComplexF64 number is 128 bits. The vector textbfp_i contains 3 complex numbers per component, and n_x times n_y times n_z vectors. Thus, the size of textbfp_i is 384 times n_x times n_y times n_z bits. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It is strongly advised to have at least 8 times that amount of storage in RAM or VRAM available. This amount has some buffer in it, but to use all the operations shown above and other scripts, it is the amount of memory with which no errors caused by lack of memory should arise.","category":"page"},{"location":"usage/#Multi-threading","page":"Usage","title":"Multi-threading","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"When using Gila on a CPU, many functions can take advantage of multiple compute threads, which can bring massive speed gains. It is highly advised to use Gila within a Julia REPL that has access to as many threads as possible. For example, to launch a REPL with 8 threads, the following line needs to be entered in a terminal:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia -t 8","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Then, to make the most use of those threads, two packages that are used by Gila need to be set to use those threads. This can be done by setting the following before using any defined operators:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using Base.Threads # to access the number of threads given to the REPL\n\nusing FFTW\nusing LinearAlgebra.BLAS\n\nnum_threads = nthreads()\nBLAS.set_num_threads(num_threads)\nFFTW.set_num_threads(num_threads)","category":"page"},{"location":"library/#Library","page":"API Reference","title":"Library","text":"","category":"section"},{"location":"library/","page":"API Reference","title":"API Reference","text":"The following is the exhaustive list of the API available to users, accompanied by explanations.","category":"page"},{"location":"library/#Module-Index","page":"API Reference","title":"Module Index","text":"","category":"section"},{"location":"library/","page":"API Reference","title":"API Reference","text":"Modules = [GilaElectromagnetics]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"library/#Detailed-API","page":"API Reference","title":"Detailed API","text":"","category":"section"},{"location":"library/","page":"API Reference","title":"API Reference","text":"note: Union of complex types\nIn the following type and function list, there will be mentions of the type AbstractArray{T}. This T is described as :T<:Union{ComplexF64,ComplexF32}For every function signature that includes T, it is specified as such.","category":"page"},{"location":"library/","page":"API Reference","title":"API Reference","text":"Modules = [GilaElectromagnetics]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"library/#GilaElectromagnetics.GlaExtInf","page":"API Reference","title":"GilaElectromagnetics.GlaExtInf","text":"GlaExtInf\n\nInformation for mapping between general source and target volumes.\n\nFields\n\nminScl::NTuple{3,Rational}: Common minimum cell size (in units of wavelength).\ntrgDiv::NTuple{3,Integer}: Divisions in each cartesian index of source volume.\nsrcDiv::NTuple{3,Integer}: Divisions in each cartesian index of target volume.\ntrgCel::NTuple{3,Integer}: Cells in a target partition.\nsrcCel::NTuple{3,Integer}: Cells in a source partition.\ntrgPar::CartesianIndices: Identification of volume partition with grid offsets in target volume.\nsrcPar::CartesianIndices: Identification of volume partition with grid offsets in source volume.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaExtInf-Tuple{GlaVol, GlaVol}","page":"API Reference","title":"GilaElectromagnetics.GlaExtInf","text":"GlaExtInf(trgVol::GlaVol, srcVol::GlaVol)::GlaExtInf\n\nConstructor for `GlaExtInf, a memory structure for translating between distinct grid layouts. Treats grid mismatch.\n\nArguments\n\ntrgVol::GlaVol: Target volume definition, see GlaVol.\nsrcVol::GlaVol: Source volume definition, see GlaVol.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.GlaKerOpt","page":"API Reference","title":"GilaElectromagnetics.GlaKerOpt","text":"GlaKerOpt\n\nGreen function operator assembly and kernel operation options.\n\nFields\n\nfrqPhz::Number: Multiplicative scaling factor allowing for complex frequencies.\nintOrd::Integer: Gauss-Legendre integration order for cells in contact.\nadjMod::Bool: Flip between operator and operator adjoint.\ndevMod::Union{Bool,Array{<:Bool,1}}: Boolean vector representing activation of GPUs\nnumTrd::Union{Tuple{},NTuple{3,Integer}}: Number of threads to use when running GPU kernels.\nnumBlk::Union{Tuple{},NTuple{3,Integer}}: Number of threads to use when running GPU kernels.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaKerOpt-Tuple{Bool}","page":"API Reference","title":"GilaElectromagnetics.GlaKerOpt","text":"GlaKerOpt(devStt::Bool)\n\nSimplified GlaKerOpt constructor where default parameters are given depending on the GPU activation.\n\nArguments\n\ndevStt::Bool: Whether to activate the GPU (true) or CPU (false).\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.GlaOpr","page":"API Reference","title":"GilaElectromagnetics.GlaOpr","text":"GlaOpr(cel::NTuple{3, Int}, scl::NTuple{3, Rational}, \norg::NTuple{3, Rational}=(0//1, 0//1, 0//1); \nuseGpu::Bool=false, setTyp::DataType=ComplexF64)::GlaOpr\n\nConstruct a self Green operator.\n\nArguments\n\ncel::NTuple{3, Int}: The number of cells in each dimension.\nscl::NTuple{3, Rational}: The size of each cell in each dimension (in units of wavelength).\norg::NTuple{3, Rational}=(0//1, 0//1, 0//1): The origin of the volume in each dimension (in units of wavelength).\nuseGpu::Bool=false: Whether to use the GPU (true) or CPU (false).\nsetTyp::DataType=ComplexF64: The element type of the operator. Must be a subtype of Complex.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaOpr-2","page":"API Reference","title":"GilaElectromagnetics.GlaOpr","text":"GlaOpr\n\nAbstraction wrapper for GlaOprMem. \n\nFields\n\nmem::GlaOprMem: Data to process the Green function, see GlaOprMem.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaOpr-Tuple{Tuple{Int64, Int64, Int64}, Tuple{Rational, Rational, Rational}, Tuple{Rational, Rational, Rational}, Tuple{Int64, Int64, Int64}, Tuple{Rational, Rational, Rational}, Tuple{Rational, Rational, Rational}}","page":"API Reference","title":"GilaElectromagnetics.GlaOpr","text":"GlaOpr(celSrc::NTuple{3, Int}, sclSrc::NTuple{3, Rational}, \norgSrc::NTuple{3, Rational}, celTrg::NTuple{3, Int}, \nsclTrg::NTuple{3, Rational}, orgTrg::NTuple{3, Rational}; \nuseGpu::Bool=false, setTyp::DataType=ComplexF64)::GlaOpr\n\nConstruct an external Green's operator.\n\nArguments\n\ncelSrc::NTuple{3, Int}: The number of cells in each dimension of the source volume.\nsclSrc::NTuple{3, Rational}: The size of each cell in each dimension of the source volume (in units of wavelength).\norgSrc::NTuple{3, Rational}: The origin of the source volume in each dimension (in units of wavelength).\ncelTrg::NTuple{3, Int}: The number of cells in each dimension of the target volume.\nsclTrg::NTuple{3, Rational}: The size of each cell in each dimension of the target volume (in units of wavelength).\norgTrg::NTuple{3, Rational}: The origin of the target volume in each dimension (in units of wavelength).\nuseGpu::Bool=false: Whether to use the GPU (true) or CPU (false).\nsetTyp::DataType=ComplexF64: The element type of the operator. Must be a subtype of Complex.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.GlaOprMem","page":"API Reference","title":"GilaElectromagnetics.GlaOprMem","text":"GlaOprMem\n\nStorage structure for a Green's function operator.\n\nFields\n\ncmpInf::GlaKerOpt: Computation information, settings and kernel options, see GlaKerOpt.\ntrgVol::GlaVol: Target volume of Green function.\nsrcVol::GlaVol: Source volume of Green function.\nmixInf::GlaExtInf: Information for matching source and target grids, see GlaExtInf.\ndimInf::NTuple{3,Integer}: Dimension information for Green function volumes, host side.\negoFur::AbstractArray{<:AbstractArray{T},1}: Unique Fourier transform data for circulant Green function.\nfftPlnFwd::AbstractArray{<:AbstractFFTs.Plan,1}: Forward Fourier transform plans.\nfftPlnRev::AbstractArray{<:AbstractFFTs.ScaledPlan,1}: Reverse Fourier transform plans.\nphzInf::AbstractArray{<:AbstractArray{T},1}: Phase vector for splitting Fourier transforms.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaOprMem-Union{Tuple{T}, Tuple{GlaKerOpt, GlaVol}, Tuple{GlaKerOpt, GlaVol, Union{Nothing, GlaVol}}} where T<:Union{ComplexF64, ComplexF32}","page":"API Reference","title":"GilaElectromagnetics.GlaOprMem","text":"  GlaOprMem(cmpInf::GlaKerOpt, trgVol::GlaVol,\nsrcVol::Union{GlaVol,Nothing}=nothing, \negoFur::Union{AbstractArray{<:AbstractArray{T}},\nNothing}=nothing)::GlaOprMem\n\nPrepare memory for Green's function operator. When called with a single GlaVol,  or identical source and target volumes, yields the self construction. \n\nArguments\n\ncmpInf::GlaKerOpt: Computation information, settings and kernel options, see GlaKerOpt.\ntrgVol::GlaVol: Target volume or self volume definition.\nsrcVol::Union{GlaVol,Nothing}=nothing: Source volume for external construction.\negoFur::Union{AbstractArray{<:AbstractArray{T}},Nothing}=nothing): Unique Fourier transform data for Green's function.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.GlaVol","page":"API Reference","title":"GilaElectromagnetics.GlaVol","text":"  GlaVol(cel::Array{<:Integer,1}, celScl::NTuple{3,Rational}, \norg::NTuple{3,Rational}, grdScl::NTuple{3,Rational}=celScl)::GlaVol\n\nConstructor for Gila Volumes.\n\nArguments\n\ncel::Array{<:Integer,1}: Array of the number of cells in each dimension of the volume.\ncelScl::NTuple{3,Rational}: The size of each cell in each dimensions of the volume (in units of wavelength).\norg::NTuple{3,Rational}: The origin of the volume in each dimension (in units of wavelength).\ngrdScl::NTuple{3,Rational}=celScl: Spatial location of the center of each cell contained in the volume.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.GlaVol-2","page":"API Reference","title":"GilaElectromagnetics.GlaVol","text":"GlaVol\n\nBasic spatial memory structure for a volume.\n\nFields\n\ncel::NTuple{3,Integer}: Tuple of cells in rectangular prism.\nscl::NTuple{3,Rational}: Relative side length of a cuboid voxel (cell) compared to the wavelength.\norg::NTuple{3,Rational}: Center position of the domain.\ngrd::Array{<:StepRange,1}: Spatial location of the center of each cell contained in the volume.\n\n\n\n\n\n","category":"type"},{"location":"library/#GilaElectromagnetics.egoOpr!-Union{Tuple{T}, Tuple{GlaOprMem, AbstractArray{T}}} where T<:Union{ComplexF64, ComplexF32}","page":"API Reference","title":"GilaElectromagnetics.egoOpr!","text":"  egoOpr!(egoMem::GlaOprMem, \nactVec::AbstractArray{T})::AbstractArray{T}\n\nApplies the electric Green function to actVec (polarisation current density), returning the output vector field. actVec is internally modified by egoOpr! to reduce needed allocation. \n\nArguments\n\negoMem::GlaOprMem - The memory for Green's function operator.\nactVec::AbstractArray{T} The tensor representing the polarisation current density, where the first three indices represent 3D coordinates, and the fourth the density at the given coordinate.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.glaSze-Tuple{GlaOpr, Int64}","page":"API Reference","title":"GilaElectromagnetics.glaSze","text":"glaSze(op::GlaOpr, dim::Int)\n\nReturns the size of the input/output arrays for a GlaOpr in tensor form in a specified dimension.\n\nArguments\n\nop::GlaOpr: The operator to check.\ndim::Int: The index of the dimension to check.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.glaSze-Tuple{GlaOpr}","page":"API Reference","title":"GilaElectromagnetics.glaSze","text":"glaSze(opr::GlaOpr)\n\nReturns the size of the input/output arrays for a GlaOpr in tensor form.\n\nArguments\n\nop::GlaOpr: The operator to check.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.isadjoint-Tuple{GlaOpr}","page":"API Reference","title":"GilaElectromagnetics.isadjoint","text":"isadjoint(opr::GlaOpr)\n\nChecks if the operator is the adjoint of the Green's operator.\n\nArguments\n\nopr::GlaOpr: The operator to check.\n\nReturns\n\ntrue if the operator is the adjoint, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.isexternaloperator-Tuple{GlaOpr}","page":"API Reference","title":"GilaElectromagnetics.isexternaloperator","text":"  isexternaloperator(opr::GlaOpr)\n\nChecks if the operator is an external Green's operator.\n\nArguments\n\nopr::GlaOpr: The operator to check.\n\nReturns\n\ntrue if the operator is an external Green's operator, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/#GilaElectromagnetics.isselfoperator-Tuple{GlaOpr}","page":"API Reference","title":"GilaElectromagnetics.isselfoperator","text":"isselfoperator(opr::GlaOpr)\n\nChecks if the operator is a self Green's operator.\n\nArguments\n\nopr::GlaOpr: The operator to check.\n\nReturns\n\ntrue if the operator is a self Green's operator, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following section serves as a showcase of possible applications of GilaElectromagnetics. Every one after the basic example assumes that the operators presented in the usage section were defined beforehand. Only the most important parts of the source code that made the shown figures are presented here, otherwise this section would be unnecessarily long. However, complete scripts are available in the examples/ folder of the package repository. They cover everything in this showcase, including the code to produce the figures.","category":"page"},{"location":"examples/#Basic-Example","page":"Examples","title":"Basic Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following creates a self Green's function that acts on a vector of random sources. The Green's function acts in a domain that is 8x8x8 cells, each with a size that is 1/32 of a wavelength. The domain is thus 1/4 of a wavelength in each direction.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GilaElectromagnetics\n\nnum_cells = (8, 8, 8)\ncell_size = (1//32, 1//32, 1//32)\nhas_gpu = false # Set to true if you have a CUDA enabled GPU\nconst T = ComplexF32 # Set to ComplexF64 for double precision\n\nG = GlaOpr(num_cells, cell_size; useGpu=has_gpu, setTyp=T)\nsource_vec = rand(eltype(G), size(G, 2))\nfield_vec = G * source_vec # Apply the Greens operator to the source vector","category":"page"},{"location":"examples/#dipole","page":"Examples","title":"Dipole in a cube","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For all cases presented below (dipole example, wave guide example, thin film example), the following packages must be imported:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Computation\nusing Base.Threads\nusing FFTW\nusing IterativeSolvers\nusing LinearAlgebra\nusing LinearAlgebra.BLAS\nusing Random\nusing ..GilaOperators # if the operators are in an included GilaOperators.jl file\nusing CUDA\n\n# Plotting\nusing GLMakie\nusing GeometryBasics\nusing Colors\nusing Printf","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Also, to ensure consistency for packages that themselves use Random, the following line is included:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Random.seed!(0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"All code sections presented below are written for maximum clarity. They could be rewritten more concisely, which could be better for certain users.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This first example is the simplest. A single electric dipole textbfp_i will be placed approximately in the middle of a dielectric cube, itself embedded in empty space. The objective is to visualize the resulting electric field. Both the intensity and the real part (in every direction) are of interest.","category":"page"},{"location":"examples/#Volume-and-medium","page":"Examples","title":"Volume and medium","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To begin, we define most of the relevant physical quantities to describe the system:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# dimensions\nnum_cells_side = 32 # defines cube of 32x32x32\nnum_cells_side_vac = 128 # defines cube of 128x128x128\ncells_per_wavelength = 32\n\n# medium\nχ_fill = ComplexF32(1.5 + 0im)\n\n# source (dipole)\npos_x = 16\npos_y = 16\npos_z = 16\ndip_x = 0\ndip_y = 0\ndip_z = 30\n\n# visualisation\ndst_slice = 64","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Special care must be taken when specifying the type of complex variables while using Gila. The user must either use ComplexF32 for speed and memory gains, or ComplexF64 for accuracy gains. It is not recommended to mix these two types in one single script, hence why their declaration is explicit in the code presented.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, the computation using Gila can be done, but only for the inside of the dielectric. We cannot just solve for both the dielectric and the empty space, because the solver doesn't converge for χ = 0. We can use the exact same logic as presented in the scattering section of the usage page:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# memory for volume\ncells = (num_cells_side, num_cells_side, num_cells_side)\nscale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)\ncoord = (0//1, 0//1, 0//1)\n\n# memory for medium (small cube of dielectric)\nχ = fill(χ_fill, num_cells_side, num_cells_side, num_cells_side)\n\n# Lippmann-Schwinger operator\nls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)\n\n# memory for dipole\np_i = zeros(eltype(ls), num_cells_side, num_cells_side, num_cells_side, 3)\np_i[pos_x, pos_y, pos_z, :] = [dip_x, dip_y, dip_z]\n\n# solution for total polarisation current density \np_t = solve(ls, p_i)","category":"page"},{"location":"examples/#empty","page":"Examples","title":"Embedding in empty space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now have p_t, which is only present in the dielectric cube. A trick to solve for the fields is to embed this array in a bigger one filled with zeros, which represents empty space. It makes physical sense because where there is no matter there cannot be presence of a dipole. This can be implemented in the following way:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# memory for volume with empty space\ncells_vac = (num_cells_side_vac, num_cells_side_vac, num_cells_side_vac)\n\n# position of small cube within bigger one\n# this is specifically to position it near the middle\npos_cube_begin = Int((num_cells_side_vac / 2) - (num_cells_side / 2))\npos_cube_end = Int((num_cells_side_vac / 2) + (num_cells_side / 2) - 1)\n\n# insert the p_t vectors in the empty space\np_t_vac = zeros(ComplexF32, num_cells_side_vac, num_cells_side_vac, num_cells_side_vac, 3)\np_t_vac[pos_cube_begin:pos_cube_end, pos_cube_begin:pos_cube_end, pos_cube_begin:pos_cube_end, :] .= p_t","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"With the sources embedded in empty space, nothing prevents the generation of a Green's operator. Thus, the field can be obtained like this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# memory for Green's function\nG_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)\n\n# obtaining the electric field\ne_t_vac = G_0_vac * p_t_vac","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is what we aimed to obtain. All that remains is to visually represent this field.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Alternative trick for empty space\nIf one wants to define chi with some empty space cells, it is possible to give a very low susceptibility value to approximate chi = 0. Of course, this comes at a loss of accuracy, but it might be good enough depending on the use case when empty space is approximated at sim 10^-5.In the future, a preconditionner for the solver will allow materials of value chi leq 0 to have a solution that converges, making the workarounds irrelevant.","category":"page"},{"location":"examples/#Visualization","page":"Examples","title":"Visualization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As specified, the visualization source code for the figures is available, but is not as relevant as the solving steps in the context of the GilaElectromagnetics package. Quick tips will be provided to guide towards a clear representation of the physics, but the presentation of the results will be straightforward.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The central package used for visualisations is Makie.jl. It allows for the most options compared to it's alternative when it comes to interactivity and customizability. As seen in the list of packages above, GLMakie is used as the choice of backend package to harness the power of a dedicated graphics card with OpenGL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We have obtained a 3D vector field in the previous section. The first way one would think of representing it visually is with a function such as arrows, where every cell has its electric field vector represented. The problem with the 3D nature of the field is that such a representation gets extremely cluttered. It is advised to choose a 2D plane within the 3D field as a way to declutter the view.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is not guaranteed however that the vectors within the 2D plane are coplanar with it, which leads to akwardness in the usage of the arrows function in 2D plane. This is why the presented figures here show heat maps as a way to show the data. Using Makie's heatmap function along with Colorbar, it is possible to reprint the intensity and the real parts of the electric field in a plane of the volume in a clear and intuitive way.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the initialization of the volume and the medium, the parameter dst_slice was set. If the plane represented was in directions xz, this would mean that the slice is taken at the set number of cells from the origin. This can be seen in the following image where the heat map of the intensity E^2 is accompanied by a visual aid and information on the system :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in cube - intensity - slice on dipole)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This image represents the exact physical case with the numeric values presented above in the xz plane. For clarity and since the intensity is strictly positive, the color scales logarithmically. In addition, the real part of the electric field vector in every Cartesian direction, respectively E_x, E_y, E_z, for this same system is shown here :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in cube - real part - slice on dipole)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As it can be seen, the values of the electric field at the dipole saturate the colour map. To see more clearly the behaviour of the field as it gets further away from the dipole, the same figures were made but with the plane of visualization further away from the dipole, at dst_slice = 70 :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in cube - intensity - slice offset)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the real part at this distance of visualization:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in cube - real part - slice offset)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The decay of the field with the behaviour on the edge of the cube is as expected.","category":"page"},{"location":"examples/#wave-guide","page":"Examples","title":"Dipole in a wave guide","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similarly, the second example shows an electric dipole located in a wave guide. The same process of embedding the dielectric in a bigger space will be used.","category":"page"},{"location":"examples/#Volume-and-medium-2","page":"Examples","title":"Volume and medium","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Very similarly to the cube, we define relevant physical quantities, with more granularity on the dimensions of the volumes. The embedding position of the dielectric in vacuum is predetermined here, where the position_guide variables give the number of cells between the beginning of the guide and the relevant plane crossing the origin :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# dimensions of guide\nnum_cellsx = 256\nnum_cellsy = 34\nnum_cellsz = 34\n\n# dimensions of space\nnum_cellsx_vac = num_cellsx\nnum_cellsy_vac = 256\nnum_cellsz_vac = 128\ncells_per_wavelength = 32\n\n# location of guide (only intended for guide along x)\nposition_guide_y = 110\nposition_guide_z = 55\n\n# medium\nχ_fill = ComplexF32(1.5 + 0im)\n\n# source\npos_x = 50 \npos_y = 16\npos_z = 16\ndip_x = 0\ndip_y = 0\ndip_z = 10\n\n# visualisation\ndst_slice = 135\nslice_id = \"xz\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As specified in a comment, this prepares a wave guide along the x-axis only, but the program can be modified for any direction. ","category":"page"},{"location":"examples/#Decay-and-loss-at-boundaries","page":"Examples","title":"Decay and loss at boundaries","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"An important detail must be addressed before solving for the electric field. A key difference with the cube example is that the dielectric goes all the way to the edges of the defined volume. A conventional wave guide would be normally treated under an approximation of infinite length, because its length is much bigger than the size of its cross-section. Here, the edges prevent this approximation, because the computation treats them as a medium-vacuum interface.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To massively reduce the impact of this interface, we can introduce a gradual decay of Re(chi), which makes the transition from dielectric to vacuum much smoother, reducing reflection effects in the guide. In addition, we can gradually introduce loss in the medium, by increasing Im(chi) when approaching the boundary.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following function scales the decay with a tanh function, going from Re(chi)timestanh(3) to Re(chi)timestanh(-3) as the boundary approaches. This decay happens on a length determined by the parameter decay_length given in number of wavelengths. Similarly, loss is introduced on this same length proportionally to x^2, going from Im(chi) = 0 to Im(chi) = 01 : ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function medium_decay_tanh!(cells, χ, χ_fill, d)\n  for i in 1:d\n    χ[d-i+1, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n    χ[cells[1] - d + i, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n  end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Applying this function to the already defined medium will greatly help the simulations to have intended results everywhere except where the decay and loss happens. In these locations, the fields should simply vanish.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: function() VS function!()\nA typical function returns something, while a function! modifies one or more of it's input variables. The ! is Julia convention to indicate this fact.As an example, medium_decay_tanh! modifies the χ variable directly. Some functions in Gila use this convention, notably egoOpr! and other internal functions.","category":"page"},{"location":"examples/#Solutions","page":"Examples","title":"Solutions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Solving for the field is just like the cube case, with the addition of the decay function. A script to obtain it would look like this :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# solving in the dielectric\ncells = (num_cellsx, num_cellsy, num_cellsz)\nscale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)\ncoord = (0//1, 0//1, 0//1);\n\nχ = fill(χ_fill, num_cellsx, num_cellsy, num_cellsz)\ndecay_length = 1\nmedium_decay_tanh!(cells, χ, χ_fill, decay_length * cells_per_wavelength);\n\nls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)\n\np_i = zeros(eltype(ls), num_cellsx, num_cellsy, num_cellsz, 3)\np_i[pos_x, pos_y, pos_z, :] = [dip_x, dip_y, dip_z]\n\np_t = solve(ls, p_i)\n\n# embedding in empty space\ncells_vac = (num_cellsx, num_cellsy_vac, num_cellsz_vac)\n\nend_guide_y = position_guide_y + num_cellsy - 1\nend_guide_z = position_guide_z + num_cellsz - 1\n\np_t_vac = zeros(ComplexF32, num_cellsx, num_cellsy_vac, num_cellsz_vac, 3)\n\np_t_vac[:, position_guide_y:end_guide_y, position_guide_z:end_guide_z, :] .= p_t\n\nG_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)\n\ne_t_vac = G_0_vac * p_t_vac","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can now visualize the field in the guide with heatmaps, with the viewed plane slightly away from where the dipole is so that the gradient of colour is less saturated:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in guide - intensity - xz)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the real parts:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in guide - real - xz)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also analyze the field in the yz plane to see how it leaks out of the guide:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in guide - intensity - yz)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And finally, for the real parts:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: dipole in guide - real - yz)","category":"page"},{"location":"examples/#thin-film","page":"Examples","title":"Incident wave on a thin film","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As the final example, we will analyze the behaviour of a plane wave hitting a thin film of dielectric. The general process is still the same, but the treatment of the wave itself is worth discussing.","category":"page"},{"location":"examples/#Volume-and-medium-3","page":"Examples","title":"Volume and medium","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define the information on the volume and the medium with the following variables:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# dimensions\nnum_cellsx = 256\nnum_cellsy = 256\nnum_cellsz = 24\nnum_cellsz_vac = 128\ncells_per_wavelength = 32\n\n# medium\nposition_film = 52\nχ_fill = ComplexF32(1.5 + 0im)\ndecay_length = 1\n\n# visualisation\ndst_slice = 128","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because the film goes all the way to the edges of the volume, we need to apply decay and loss again, but this time for two directions. The following function accomplishes this as it was described for the guide:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function medium_decay_tanh!(cells, χ, χ_fill, d)\n  for i in 1:d\n    χ[d-i+1, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n    χ[cells[1] - d + i, :, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n  end\n  for i in 1:d\n    for x in 1:cells[1]\n      if real(χ[x, d-i+1, 1, 1]) > real((χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ))\n        χ[x, d-i+1, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n        χ[x, cells[2] - d + i, :, :] .= (χ_fill / 2) * ( tanh((6/d) * (-i + (d/2))) + 1 ) + ( (0.1/(d^2))*((i-d-1)^2) )im\n      end\n    end\n  end\nend","category":"page"},{"location":"examples/#Electric-field","page":"Examples","title":"Electric field","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We need to create a function that generates a plane wave, and then use it to define the initial polarization current density required to use the solver. An electric wave can be described as the following :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"textbfE = textbfE_0 e^i(textbfkcdottextbfr-ωt)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where the amplitude of textbfE_0 describes the amplitude of the wave, its direction dictates the direction of the electric field (the polarization of the wave), textbfk is the wave vector which dictates both wavelength and the direction of the wave front, textbfr represents a point in space, and ωt represents a phase factor that will be set to 0 arbitrarily going forward.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will do heatmaps in xz, and purposefully use a wavevector coplanar to this plane. This is only for the sake of representation, as any wave vector would work. We will also arbitrarily choose an s-polarized wave, where the direction of the electric field is perpendicular to the plane (field along y). This is all set up in the following function which gives the electric field at a point:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function electric_field(x, y, z, dir_i, dir_j, dir_k, amp, ω=0, t=0)\n  k = normalize([dir_i, dir_j, dir_k])\n  \n  if abs(k[3]) != 1\n    v = [0, 0, 1]  # use z-axis if k is not aligned with z\n  else\n    v = [0, 1, 0]  # use y-axis if k is aligned with z (would not be s pol. anymore)\n  end\n\n  # Field perpendicular to the plane containing k and the z axix (s pol.)\n  E0 = amp * normalize(cross(k, v))\n\n  return E0 * exp(1im * (dot(2π*k, [x, y, z]) - ω * t))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where the amp variable was introduced to control the amplitude of the electric field. This function is also intended to have the same wavelength as what's defined by cells_per_wavelength. We can now set up different memory elements as we did previously:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cells = (num_cellsx, num_cellsy, num_cellsz)\nscale = (1//cells_per_wavelength, 1//cells_per_wavelength, 1//cells_per_wavelength)\ncoord = (0//1, 0//1, 0//1);\n\nχ = fill(χ_fill, num_cellsx, num_cellsy, num_cellsz)\nmedium_decay_tanh!(cells, χ, χ_fill, decay_length * cells_per_wavelength);\n\nls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Recall the following equation for linear, non-dispersive and isotropic dielectric :","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"textbfp_i = chi textbfe_i","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"With for loops and this equation applied cell per cell, we can easily obtain the initial polarization current density from the electric field:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# wave vector (is normalized later)\nk_i = 1.0\nk_j = 0.0\nk_k = -2.0 # negative value looks better, not mandatory\namp = 3.0\n\np_i = zeros(eltype(ls), num_cellsx, num_cellsy, num_cellsz, 3)\n\n# p_i = χ*e_i at every cell of the dielectric\n@time for x in 1:num_cellsx\n    for y in 1:num_cellsy\n        for z in 1:num_cellsz\n            p_i[x, y, z, :] = real(electric_field((x-1) + coord[1], (y-1) + coord[2], (z-1) + coord[3], k_i, k_j, k_k, amp)) * χ[x, y, z, 1]\n        end\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This allows to solve for the total field with the solver and Green's operator:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# solving\np_t = solve(ls, p_i)\n\n# embedding\ncells_vac = (num_cellsx, num_cellsy, num_cellsz_vac)\nend_film = position_film + num_cellsz - 1\np_t_vac = zeros(ComplexF32, num_cellsx, num_cellsy, num_cellsz_vac, 3)\np_t_vac[:, :, position_film:end_film, :] .= p_t\n\n# obtaining fields\nG_0_vac = load_greens_operator(tuple(cells_vac...), scale; set_type=ComplexF32)\ne_t_vac = G_0_vac * p_t_vac","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We are now ready to plot heatmaps of this wave. Starting with different information and the intensity:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: film - 1, 0 , -2 - decay - intensity)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And then, the real parts of the field:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: film - 1, 0 , -2 - decay - real)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As intended, most of the field is contained in the y direction because of the initial s-polarisation. However, a lot more confinement of the field in the field is observed, and the values aren't very high. This is a consequence of the decay and the loss introduced. If we reproduce the same system but without introducing them, we can observe the following. For the intensity:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: film - 1, 0 , -2 - no decay - intensity)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the real parts:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: film - 1, 0 , -2 - no decay - real)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is less representative of how thin films would behave in real life, but it shows nicely how the loss \"hides\" parts of the field. A way to have realistic behaviour without suppressing the field would be to simulate a much bigger film and to exclude the edges from the visualization, but this is quite computationally expensive.","category":"page"},{"location":"examples/#Different-angle","page":"Examples","title":"Different angle","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can try to simulate a wave that glances the film at a very low angle. Phenomena of total internal reflection should be recognizable. Changing the values of the wave vector, we obtain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: tir - intensity)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, the real values of the electric field are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: tir - real)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can indeed see a reflected wave. Its odd look on both sides is due to the small size of the simulated system and to the definition of the wave. The way it's formulated, the initial field exists on both sides of the film at the beginning, which makes it behave not exactly like a wave front at the contact of a dielectric film would. Still, expected behaviour is there, and it is a good showcase of the abilities of Gila on solving different systems.","category":"page"},{"location":"examples/#GPU-example","page":"Examples","title":"GPU example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, even though the solver is not yet implemented with it, here is a short showcase on how such a simulation would be treated with computation on a CUDA enabled GPU. Most of the program stays the same, but the operators need to have their use_gpu parameter set to true:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ls = LippmannSchwinger(cells, scale, χ; set_type=ComplexF32, use_gpu=true)\n\nG_0_void = load_greens_operator(tuple(cells_void...), scale; set_type=ComplexF32, use_gpu=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In addition, the initial polarization current density needs to be converted to a CuArray in order to be treated correctly by the solver:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p_t = Array(solve(ls, CuArray(p_i)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This would result in the total electric field variable e_t_vac to be of type CuArray also. In order to do further data analysis with it, it could be necessary to convert it back to a regular array by simply using Array(e_t_vac). Right now, using CUDA to load Green's operators is working and a good way to save compute time.","category":"page"},{"location":"#GilaElectromagnetics.jl","page":"GilaElectromagnetics","title":"GilaElectromagnetics.jl","text":"","category":"section"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"GilaElectromagnetics.jl is a Julia package that provides a very efficient implementation of the discrete three-dimensional electromagnetic Green function. For a technical description of the implementation, see the associated paper. For a high-level overview of what GilaElectromagnetics does, see the concepts and usage pages. Detailed examples can be found in the examples page. The public API reference is also available.","category":"page"},{"location":"#Use-cases","page":"GilaElectromagnetics","title":"Use cases","text":"","category":"section"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"GilaElectromagnetics, or Gila for short, enables fast and precise sub-wavelength electromagnetic simulations. Below are some features Gila provides:","category":"page"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"Solving Maxwell's equations numerically in vacuum and in matter.\nApplication of the Green's function of the vacuum Maxwell vacuum operator.\nSolving the scattering problem in non-magnetic materials.\nGPU accelerated computations with CUDA.jl.","category":"page"},{"location":"#Installation","page":"GilaElectromagnetics","title":"Installation","text":"","category":"section"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"Installation can be done with Julia's package manager:","category":"page"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"julia> using Pkg\njulia> Pkg.add(\"GilaElectromagnetics\")","category":"page"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"Alternatively, in Julia's REPL, a typing ] puts you in \"Pkg mode\". In this command line package manager, installing GilaElectromagnetics can be done as follows:","category":"page"},{"location":"","page":"GilaElectromagnetics","title":"GilaElectromagnetics","text":"(@v1.10) pkg> add GilaElectromagnetics","category":"page"}]
}
