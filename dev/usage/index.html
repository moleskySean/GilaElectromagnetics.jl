<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · GilaElectromagnetics.jl Documentation</title><meta name="title" content="Usage · GilaElectromagnetics.jl Documentation"/><meta property="og:title" content="Usage · GilaElectromagnetics.jl Documentation"/><meta property="twitter:title" content="Usage · GilaElectromagnetics.jl Documentation"/><meta name="description" content="Documentation for GilaElectromagnetics.jl Documentation."/><meta property="og:description" content="Documentation for GilaElectromagnetics.jl Documentation."/><meta property="twitter:description" content="Documentation for GilaElectromagnetics.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GilaElectromagnetics.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GilaElectromagnetics</a></li><li><a class="tocitem" href="../concepts/">Concepts</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Vacuum-Green&#39;s-function"><span>Vacuum Green&#39;s function</span></a></li><li><a class="tocitem" href="#scattering"><span>Scattering problem</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Technical-details"><span>Technical details</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../library/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moleskySean/GilaElectromagnetics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moleskySean/GilaElectromagnetics.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The following presents typical uses of GilaElectromagnetics.</p><h2 id="Vacuum-Green&#39;s-function"><a class="docs-heading-anchor" href="#Vacuum-Green&#39;s-function">Vacuum Green&#39;s function</a><a id="Vacuum-Green&#39;s-function-1"></a><a class="docs-heading-anchor-permalink" href="#Vacuum-Green&#39;s-function" title="Permalink"></a></h2><p>Gila solves Maxwell&#39;s equations in a vacuum by employing finite element methods on a given volume. What Gila computes is the action of the vacuum Green&#39;s function <span>$\textbf{G}_0$</span> on a vector. The operator <span>$\textbf{G}_0$</span> is represented in memory by the structure <a href="../library/#GilaElectromagnetics.GlaOprMem"><code>GlaOprMem</code></a>. A simpler object to use which acts exactly as you would want an operator to behave is the <a href="../library/#GilaElectromagnetics.GlaOpr"><code>GlaOpr</code></a> structure. To initialize either a <a href="../library/#GilaElectromagnetics.GlaOprMem"><code>GlaOprMem</code></a> object or a <a href="../library/#GilaElectromagnetics.GlaOpr"><code>GlaOpr</code></a> object, information about the space where the equations are solved must be defined.</p><p>In Gila, volumes must be rectangular prisms, which are then subdivided into smaller volumes called <em>cells</em>. The size of these cells in a specific direction is given in fractions of a wavelength, because Gila solves a system at one given wavelength.</p><h3 id="Self-and-external-operators"><a class="docs-heading-anchor" href="#Self-and-external-operators">Self and external operators</a><a id="Self-and-external-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Self-and-external-operators" title="Permalink"></a></h3><p>The vacuum Green&#39;s function for a given volume is obtained using a <a href="../library/#GilaElectromagnetics.GlaOpr"><code>GlaOpr</code></a> constructor. There are two cases to consider. The first one is the simplest, where the source volume is the same as the target volume. The resulting operator is called the <em>self Green&#39;s operator</em>. The following example shows how to build one:</p><pre><code class="language-julia hljs"># Volume definition
cells = (8, 8, 8) # Defines a volume with 8 cells in each direction
scale = (1//32, 1//32, 1//32) # Each cell is 1/32 of a wavelength in each direction
origin = (0//1, 0//1, 0//1) # OPTIONAL: The volume is located at the origin

# Self Greens operator
G_0 = GlaOpr(cells, scale, origin)</code></pre><div class="admonition is-info"><header class="admonition-header">Origin</header><div class="admonition-body"><p>The origin in this context refers to the cell <code>(1, 1, 1)</code>, located in the corner of the volume. </p></div></div><p>Two more parameters can be passed: <code>useGpu</code> if an <em>Nvidia</em> GPU is available, and <code>setTyp</code> to either use 32 or 64 bit complex numbers (single or double precision). The syntax to use these parameters is shown here:</p><pre><code class="language-julia hljs">G_0 = GlaOpr(cells, scale, origin; useGpu=true, setTyp=ComplexF64)</code></pre><p>The second case to consider is where there are two separate volumes, or when the defined volume (source) is different from the one where a solution is desired (target). This can be useful if a medium and current sources are defined in a region, but the space to be simulated is either partially or fully contained by the source volume, or if both are completely separated. The Green&#39;s function is then called the <em>external Green&#39;s operator</em>, and it can be constructed just like the self operator, only with two volumes required :</p><pre><code class="language-julia hljs"># Source volume definition
src_cells = (src_nx, src_ny, src_nz) # tuple of Integers
src_scale = (src_sclx, src_scly, src_sclz) # tuple of Rationals
src_origin = (src_orgx, src_orgy, src_orgz) # tuple of Rationals, REQUIRED

# Target volume definition
trg_cells = (trg_nx, trg_ny, trg_nz) # tuple of Integers
trg_scale = (trg_sclx, trg_scly, trg_sclz) # tuple of Rationals
trg_origin = (trg_orgx, trg_orgy, trg_orgz) # tuple of Rationals, REQUIRED

# External Green&#39;s operator
G_0 = GlaOpr(src_cells, src_scale, src_origin, trg_cells, trg_scale, trg_origin)</code></pre><p>The same optionnal parameters for CUDA and the complex type could be given.</p><div class="admonition is-info"><header class="admonition-header">Origin</header><div class="admonition-body"><p>The origin in this context refers to the cell <code>(1, 1, 1)</code>, located in the corner of the volume. </p></div></div><p>This operator uses the <code>GlaOpr</code> type, which in itself is an abstraction wrapper for the <a href="../library/#GilaElectromagnetics.GlaOprMem"><code>GlaOprMem</code></a>. It is <em>not</em> a matrix, but it can be used as a linear operator, i.e., you can multiply a vector by it.</p><h2 id="scattering"><a class="docs-heading-anchor" href="#scattering">Scattering problem</a><a id="scattering-1"></a><a class="docs-heading-anchor-permalink" href="#scattering" title="Permalink"></a></h2><p>Gila is designed primarily to tackle the <em>scattering problem</em>, which asks to find the total field <span>$\textbf{f}_t$</span> produced, given an incident field <span>$\textbf{f}_i$</span> and a dielectric profile. This allows us to solve Maxwell&#39;s equations in matter.</p><h3 id="Theoretical-overview"><a class="docs-heading-anchor" href="#Theoretical-overview">Theoretical overview</a><a id="Theoretical-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-overview" title="Permalink"></a></h3><p>We can always decompose the total field into an incident and a scattered part:</p><p class="math-container">\[\textbf{f}_t = \textbf{f}_i + \textbf{f}_s\]</p><p>Furthermore, we define the matrix <span>$\textbf{X}$</span> to represent permittivity and permeability as such, while still using natural units :</p><p class="math-container">\[\textbf{X} =
\begin{pmatrix}
\textbf{X}_{je} &amp; \textbf{0} \\
\textbf{0} &amp; \textbf{X}_{mh}
\end{pmatrix}\]</p><p>Here, <span>$\textbf{X}_{je}$</span> and <span>$\textbf{X}_{mh}$</span> are diagonal matrices described by the electric and magnetic susceptibility <span>$\chi_e$</span> and <span>$\chi_m$</span> respectively:</p><p class="math-container">\[\textbf{X}_{je} = \frac{i}{k_0}\chi_e \textbf{I}_{3 \times 3}\]</p><p class="math-container">\[\textbf{X}_{mh} = -\frac{i}{k_0}\chi_m \textbf{I}_{3 \times 3}\]</p><p>where:</p><p class="math-container">\[\textbf{P} = \epsilon_0 \chi_e \textbf{E}\]</p><p class="math-container">\[\textbf{M} = \chi_m \textbf{H}\]</p><p>with <span>$\textbf{P}$</span>, the polarization density, and <span>$\textbf{M}$</span>, the magnetization field. </p><p>In the same way that the fields can be decomposed into incident, scattered and total parts, so can the polarization density vector: <span>$\textbf{p}_t = \textbf{p}_i + \textbf{p}_s$</span>. After such a decomposition, the constitutive relations become:</p><p class="math-container">\[\frac{i}{k_0}\textbf{p}_s = \textbf{X}\textbf{f}_t\]</p><p>Recall the <a href="../concepts/#maxwell">relevant</a> Maxwell&#39;s equations in vacuum. By their linearity, their scattered part can be written simply as:</p><p class="math-container">\[\textbf{M}_0 \textbf{f}_s = \frac{i}{k_0}\textbf{p}_s\]</p><p>Combining with the previous equation:</p><p class="math-container">\[\textbf{M}_0 \textbf{f}_s = \textbf{X}\textbf{f}_t\]</p><p>With the vacuum Green&#39;s function being the inverse of <span>$\textbf{M}_0$</span>:</p><p class="math-container">\[\textbf{f}_s = \textbf{G}_0 \textbf{X}\textbf{f}_t\]</p><p>With the decomposition of the scattered field into its total and initial parts, along with substitutions with previous equations, the following relation can be found:</p><p class="math-container">\[\textbf{f}_t - \frac{i}{k_0}\textbf{G}_0 \textbf{p}_s =\frac{i}{k_0}\textbf{G}_0 \textbf{p}_i\]</p><p>Finally, multiplying both sides by <span>$\textbf{X}$</span>, using further substitutions and decomposing the density vector the same way the fields vector was, a crucial equation is reached:</p><p class="math-container">\[(\textbf{I}_{6 \times 6} - \textbf{X}\textbf{G}_0)\textbf{p}_t = \textbf{p}_i\]</p><p>This is known as the <a href="https://en.wikipedia.org/wiki/Lippmann%E2%80%93Schwinger_equation">Lippmann-Schwinger equation</a>. In order to obtain the <em>total polarization current density</em> from the material&#39;s properties and from an initial polarization current density, the following needs to be solved:</p><p class="math-container">\[\textbf{p}_t = (\textbf{I}_{6 \times 6} - \textbf{X}\textbf{G}_0)^{-1}\textbf{p}_i\]</p><p>where <span>$\textbf{W} = (\textbf{I}_{6 \times 6} - \textbf{X}\textbf{G}_0)^{-1}$</span> is denoted as the <em>scattering operator</em>. With a way to define this operator, Gila effectively allows the Maxwell&#39;s equations to be solved in matter.</p><div class="admonition is-danger"><header class="admonition-header">Accessing specific matrices</header><div class="admonition-body"><p>It is important to note that the mathematical solutions above would apply to a single cell of a system. For a whole system, they are still correct, but the matrices and vectors are expanded, and each cell adds six elements (on the diagonal for the matrix <span>$\textbf{X}$</span>). This is explained further in the implementation examples. </p><p>It is important to to keep in mind is that these matrices become enormous very quickly as the dimensions of a volume increases. Gila&#39;s trick is to actually <em>not compute</em> the Green&#39;s function, but to only compute it&#39;s application on a vector <span>$\textbf{v}$</span>. The same would go for <span>$\textbf{W}$</span>, since it&#39;s composed of the Green&#39;s operator. Thus, Gila outputs <span>$\textbf{G}_0 \textbf{v}$</span>, <span>$\textbf{W}\textbf{p}_i$</span> (provided Lippmann-Schwinger is implemented) or anything similar.</p></div></div><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><p>This section will showcase an implementation of the scattering operator, to solve the Lippmann-Schwinger equation in this context. These can be implemented as a module in a file of a project. To begin, the following packages must be imported in order for the following code to function:</p><pre><code class="language-julia hljs"># At the beginning of an exported module
using LinearAlgebra
using JLD2
using CUDA
using GilaElectromagnetics</code></pre><p>In a nutshell, the part that takes the longest to compute for Gila are <em>fast Fourier transforms (FFTs)</em>. However, the implementation of <a href="https://juliaio.github.io/JLD2.jl/dev/">JLD2</a> gives the possibility of storing (serializing) these FFTs, drastically speeding things up for subsequent uses of Gila for systems of identical dimensions. The following function simply verifies the existence of a folder named <code>preload</code> where the Fourier transforms will be stored:</p><pre><code class="language-julia hljs">function get_preload_dir()
    found_dir = false
    dir = &quot;preload/&quot;
    for i in 1:10
        if !isdir(dir)
            dir = &quot;../&quot;^i * &quot;preload/&quot;
        else
            found_dir = true
            break
        end
    end
    if !found_dir
        error(&quot;Could not find preload directory. Please create a directory named &#39;preload&#39; in the current directory or parent directories.&quot;)
    end
    return dir
end</code></pre><p>The following function implements the <a href="../library/#GilaElectromagnetics.GlaOpr"><code>GlaOpr</code></a> with the possibility of obtaining it faster if it was serialized before:</p><pre><code class="language-julia hljs">function load_greens_operator(cells::NTuple{3, Int}, scale::NTuple{3, Rational{Int}};
                              set_type=ComplexF64, use_gpu::Bool=false)

    # Define the name of the FFT file
	preload_dir = get_preload_dir()
	type_str = set_type == ComplexF64 ? &quot;c64&quot; : (set_type == ComplexF32 ? &quot;c32&quot; : &quot;c16&quot;)
	fname = &quot;$(type_str)_$(cells[1])x$(cells[2])x$(cells[3])_$(scale[1].num)ss$(scale[1].den)x$(scale[2].num)ss$(scale[2].den)x$(scale[3].num)ss$(scale[3].den).jld2&quot;
	fpath = joinpath(preload_dir, fname)

    # If file exists, unserialise and return GlaOpr
	if isfile(fpath)
		file = jldopen(fpath)
		fourier = file[&quot;fourier&quot;]
		if use_gpu
			fourier = CuArray.(fourier)
		end
		options = GlaKerOpt(use_gpu)
		volume = GlaVol(cells, scale, (0//1, 0//1, 0//1))
		mem = GlaOprMem(options, volume; egoFur=fourier, setTyp=set_type)
		return GlaOpr(mem)
	end

    # If file doesn&#39;t exist, generate GlaOpr, save it and return it
	operator = GlaOpr(cells, scale; setTyp=set_type, useGpu=use_gpu)
	fourier = operator.mem.egoFur
	if use_gpu
		fourier = Array.(fourier)
	end
	jldsave(fpath; fourier=fourier)
	return operator
end</code></pre><p>With this function prepared, the memory structure of the Lippmann-Schwinger and its constructors can be defined. The following simply creates the <code>struct</code> for it with some error checking and preparation for the use of CUDA if required:</p><pre><code class="language-julia hljs">struct LippmannSchwinger
	greens_op::GlaOpr
	medium::AbstractArray{&lt;:Complex, 4}

    # Simple constructor
	function LippmannSchwinger(greens_op::GlaOpr, medium::AbstractArray{&lt;:Complex})

        # Verify if the dimensions and type of GlaOpr and the medium match.
		if glaSze(greens_op, 1)[1:3] != size(medium)
			println(glaSze(greens_op, 1)[1:3])
			println(&quot;!=&quot;)
			println(size(medium))
			throw(DimensionMismatch(&quot;Green&#39;s operator and medium must have the same size.&quot;))
		end
		if eltype(greens_op) != eltype(medium)
			throw(ArgumentError(&quot;Medium must have the same element type as the Green&#39;s operator.&quot;))
		end

        # Reshape to match the mathematical definitions of the medium
		medium = reshape(medium, glaSze(greens_op, 1)[1:3]..., 1)

        # Make the medium array compatible with CUDA if it&#39;s set up
		if greens_op.mem.cmpInf.devMod
			medium = CuArray(medium)
		end

		new(greens_op, medium)
	end
end</code></pre><p>The definition of the medium as an rank 4 tensor is more intuitive for the user. The first three dimensions simply describe the indices of a cell, and the element in the fourth dimension is the complex <span>$\chi_e$</span> value at the chosen cell. This tensor is then reshaped to correspond to how <span>$\textbf{X}$</span> was defined.</p><div class="admonition is-danger"><header class="admonition-header">Materials treated by Gila</header><div class="admonition-body"><p>GilaElectromagnetics can only treat non-magnetic materials, as they are the most common in the field of nano-optics. This is why the medium only defines the electric susceptibility. For now, only values of susceptibility with <span>$\Re(\chi_e) &gt; 0$</span>  converge for the iterative methods used in the following sections. However, there is current development on a preconditioner which will allow negative real parts of the electric susceptibility to be used without convergence problems. This will make simulations of metals possible, and simplify the <a href="../examples/#empty">treatement of empty space</a>.</p></div></div><p>It can also be useful to have a constructor of <code>LippmannSchwinger</code> that directly takes the definition of the cells, the scale, the medium and other parameters:</p><pre><code class="language-julia hljs">function LippmannSchwinger(cells::NTuple{3, Int}, scale::NTuple{3, Rational{Int}},
                           medium::AbstractArray{&lt;:Complex};
                           set_type=ComplexF64, use_gpu::Bool=false)

	greens_op = load_greens_operator(cells, scale; set_type=set_type, use_gpu=use_gpu)
	return LippmannSchwinger(greens_op, medium)
end</code></pre><p>With this operator not being a matrix but its own memory type, some mathematical and typical Julia functions ought to be defined:</p><pre><code class="language-julia hljs"># Informations on Lippmann-Schwinger
Base.size(op::LippmannSchwinger) = size(op.greens_op)
Base.size(op::LippmannSchwinger, dim::Int) = size(op.greens_op, dim)
glaSze(op::LippmannSchwinger) = glaSze(op.greens_op)
glaSze(op::LippmannSchwinger, dim::Int) = glaSze(op.greens_op, dim)
Base.eltype(op::LippmannSchwinger) = eltype(op.greens_op)

# Redefinition of the multiplication
function Base.:*(op::LippmannSchwinger, x::AbstractArray)
	if op.greens_op.mem.cmpInf.devMod
		x = CuArray(x)
	end
	gx = reshape(op.greens_op * x, glaSze(op, 1))
	return x - reshape(op.medium .* gx, size(x))
end
LinearAlgebra.mul!(y::AbstractArray, op::LippmannSchwinger, x::AbstractArray) = y .= op * x</code></pre><p>Similar techniques are implemented with Gila so that multiplying a Green&#39;s operator or attempting to get information on it is more seamless. The final step consists in using a solver to solve <span>$\textbf{p}_t = (\textbf{I}_{6 \times 6} - \textbf{X}\textbf{G}_0)^{-1}\textbf{p}_i$</span>. A simple implementation of one would go like this:</p><pre><code class="language-julia hljs">using IterativeSolvers

function solve(ls::LippmannSchwinger, i::AbstractArray{&lt;:Complex, 4};
               solver=bicgstabl)

    # Inversion of Lippmann-Schwinger
    out = solver(ls, reshape(deepcopy(i), prod(size(i))))
    return reshape(out, size(i))
end</code></pre><p>Two main solvers from <a href="https://iterativesolvers.julialinearalgebra.org/stable/">IterativeSolvers.jl</a> were tested and verified to work : BiCGStab and GMRES.</p><div class="admonition is-danger"><header class="admonition-header">Usage of GPU with solvers</header><div class="admonition-body"><p>Currently, activating the use of CUDA and using a solver from <code>IterativeSolvers</code> results in an error. This is due to these solvers not working with the <code>CuArray</code> type of CUDA. Implementing a fix to this problem is feasible for a user, as very few changes to these packages are required. A working BiCGStab version for this use case is currently in development.</p></div></div><p>As presented here, the solving function returns a rank 4 tensor, or an array of size 4, where the first three indices choose a cell, and the fourth contains the <span>$\textbf{p}_t$</span> vector at that cell. Maxwell&#39;s equations in the medium are thus solved with this function.</p><div class="admonition is-info"><header class="admonition-header">Redefinition of the multiplication</header><div class="admonition-body"><p>The redefinition of the multiplication might seem odd, but it is essential to achieve the form <span>$\textbf{I}_{6 \times 6} - \textbf{X}\textbf{G}_0$</span> in the iterative solvers. It is what allows BiCGStab or other algorithms to output <span>$\textbf{W}\textbf{p}_i$</span>, the different multiplications come in handy in their underlying workings. </p></div></div><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>The demonstrated solver for the scattering problem gives the total polarization current density. If an electric field is desired, the following equation can be used:</p><p class="math-container">\[\textbf{e}_t = \textbf{G}_0 \textbf{p}_t\]</p><p>The only thing required is to define Green&#39;s operator for the volume. With the definition of the self Green&#39;s operator showed above and the solver, finding the total electric field for the scattering problem can be done as such:</p><pre><code class="language-julia hljs"># Define the volume
cells = (n_x, n_y, n_z)
scale = (scl_x, scl_y, scl_z)

# Define the medium, this is just a simple example
medium = fill(1.0 + 0.0im, n_x, n_y, n_z)

# Define the operator
G_0 = GlaOpr(cells, scale)
LS = LippmanSchwinger(cells, scale, medium)

# Define p_i. For this example, only one  at (i, j, k)
p_i = zeros(eltype(LS), n_x, n_y, n_z, 3)
p_i[i, j, k, :] = [1, 0, 0]

# Solve for p_t
p_t = solve(LS, p_i)

# Obtain the electric field
e_t = G_0 * p_t</code></pre><p>As mentioned previously, multiplication of a Green&#39;s operator with a vector is already well-defined by Gila.</p><div class="admonition is-info"><header class="admonition-header">Meaning of the polarization current density</header><div class="admonition-body"><p>In the context of defining an array for <span>$\textbf{p}_i$</span>, a single vector of polarization current density can be seen as an electric dipole at the point where the vector is located.</p><p>For a linear, non-dispersive and isotropic dielectric, the following relationship can relate this polarization density to the electric field:</p><p class="math-container">\[\textbf{p}_i = \chi \textbf{e}_i\]</p><p>This would apply for each cell of the defined volume.</p></div></div><h2 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h2><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The presentation above didn&#39;t present every single way to define the operators. For example, the simplest constructor of <code>GlaOpr</code> only takes in a <code>GlaOprMem</code> memory structure. It would be possible to directly define it using it&#39;s <a href="../library/#GilaElectromagnetics.GlaOprMem">structure definition</a></p><p>Multiple other functions and memory structures are made available in the API. Some allow to obtain information on the operators, such as their size or their nature (self or external operator). See the <a href="../library/">API reference</a> for more details.</p><h3 id="Boundaries-of-a-volume"><a class="docs-heading-anchor" href="#Boundaries-of-a-volume">Boundaries of a volume</a><a id="Boundaries-of-a-volume-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries-of-a-volume" title="Permalink"></a></h3><p>The behaviour of space outside the defined volume is designed to be like empty space. This is referred to as <em>open boundary conditions</em>.</p><h3 id="Memory"><a class="docs-heading-anchor" href="#Memory">Memory</a><a id="Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Memory" title="Permalink"></a></h3><p>The operators and the matrices for bigger volumes can take a lot of memory. The following is a good rule of thumb to make sure the host doesn&#39;t run out of memory.</p><p>The size of a <code>ComplexF64</code> number is 128 bits. The vector <span>$\textbf{p}_i$</span> contains 3 complex numbers per component, and <span>$n_x \times n_y \times n_z$</span> vectors. Thus, the size of <span>$\textbf{p}_i$</span> is <span>$384 \times n_x \times n_y \times n_z$</span> bits. </p><p>It is strongly advised to have at least 8 times that amount of storage in RAM or VRAM available. This amount has some buffer in it, but to use all the operations shown above and other scripts, it is the amount of memory with which no errors caused by lack of memory should arise.</p><h3 id="Multi-threading"><a class="docs-heading-anchor" href="#Multi-threading">Multi-threading</a><a id="Multi-threading-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threading" title="Permalink"></a></h3><p>When using Gila on a CPU, many functions can take advantage of multiple compute threads, which can bring massive speed gains. It is highly advised to use Gila within a Julia REPL that has access to as many threads as possible. For example, to launch a REPL with 8 threads, the following line needs to be entered in a terminal:</p><pre><code class="nohighlight hljs">julia -t 8</code></pre><p>Then, to make the most use of those threads, two packages that are used by Gila need to be set to use those threads. This can be done by setting the following before using any defined operators:</p><pre><code class="language-julia hljs">using Base.Threads # to access the number of threads given to the REPL

using FFTW
using LinearAlgebra.BLAS

num_threads = nthreads()
BLAS.set_num_threads(num_threads)
FFTW.set_num_threads(num_threads)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/">« Concepts</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 6 September 2024 16:58">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
